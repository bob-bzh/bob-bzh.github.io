<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>赏口饭吃┭┮﹏┭┮ | BoBOvOの小屋</title><meta name="author" content="BoBOvO"><meta name="copyright" content="BoBOvO"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="面经js">
<meta property="og:type" content="article">
<meta property="og:title" content="赏口饭吃┭┮﹏┭┮">
<meta property="og:url" content="https://demo.bobovo.cc/posts/056.html">
<meta property="og:site_name" content="BoBOvOの小屋">
<meta property="og:description" content="面经js">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/%E5%89%8D%E7%AB%AF.jpg">
<meta property="article:published_time" content="2023-03-15T00:00:00.000Z">
<meta property="article:modified_time" content="2023-03-15T14:00:00.000Z">
<meta property="article:author" content="BoBOvO">
<meta property="article:tag" content="🖥️代码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/%E5%89%8D%E7%AB%AF.jpg"><link rel="shortcut icon" href="/image/cat.jpg"><link rel="canonical" href="https://demo.bobovo.cc/posts/056.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"这篇文章已经有","messageNext":"天没更新了,内容可能已经过时"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '赏口饭吃┭┮﹏┭┮',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-15 14:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/nav_menu.css"><link rel="stylesheet" href="/css/readPercent.css"><link rel="stylesheet" href="/css/progress_bar.css"><link rel="stylesheet" href="/css/article.css"><link rel="stylesheet" href="/css/card_auther.css"><link rel="stylesheet" href="/css/timeline.css"><link rel="stylesheet" href="/css/footer.css"><link rel="stylesheet" href="/css/essay_page.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="/css/talks.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-blogaixinzhijia"></i><svg class="menu_icon fas fa-home" aria-hidden="true"><use xlink:href="#icon-blogaixinzhijia"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="menu_icon hide" aria-hidden="true"><use xlink:href="#icon-blogxiewenzhang"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon fas fa-archives" aria-hidden="true"><use xlink:href="#icon-blogguidang">                   </use></svg><span> 全部</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon fas fa-tags" aria-hidden="true"><use xlink:href="#icon-blogtags1">                   </use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon fas fa-folder-open" aria-hidden="true"><use xlink:href="#icon-blogfenlei1">                   </use></svg><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon fas fa-list" aria-hidden="true"><use xlink:href="#icon-blogshouye"></use></svg><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="menu_icon fas fa-music" aria-hidden="true"><use xlink:href="#icon-blogyinle">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/changelog/"><svg class="menu_icon fas fa-changelog" aria-hidden="true"><use xlink:href="#icon-blogguidang">                   </use></svg><span> 更新日志</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="menu_icon fas fa-about" aria-hidden="true"><use xlink:href="#icon-blogguanyuwomen">                   </use></svg><span> 关于</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><svg class="menu_icon fas fa-about" aria-hidden="true"><use xlink:href="#icon-blogmiao">                   </use></svg><span> 文案</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon fas fa-envelope-open" aria-hidden="true"><use xlink:href="#icon-blogliuyanban">                   </use></svg><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/talks/"><i class="fa-fw icon-blogliuyanban"></i><svg class="menu_icon fas fa-envelope-open" aria-hidden="true"><use xlink:href="#icon-blogliuyanban"></use></svg><span> 动态</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-bloglianjie"></i><svg class="menu_icon fas fa-link" aria-hidden="true"><use xlink:href="#icon-bloglianjie"></use></svg><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/前端.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="BoBOvOの小屋"><span class="site-name">BoBOvOの小屋</span><!--和风天气组件      --><!--#he-plugin-simple--><!--#none_space--></a></span><!--导航栏中间    --><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-blogaixinzhijia"></i><svg class="menu_icon fas fa-home" aria-hidden="true"><use xlink:href="#icon-blogaixinzhijia"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="menu_icon hide" aria-hidden="true"><use xlink:href="#icon-blogxiewenzhang"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon fas fa-archives" aria-hidden="true"><use xlink:href="#icon-blogguidang">                   </use></svg><span> 全部</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon fas fa-tags" aria-hidden="true"><use xlink:href="#icon-blogtags1">                   </use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon fas fa-folder-open" aria-hidden="true"><use xlink:href="#icon-blogfenlei1">                   </use></svg><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon fas fa-list" aria-hidden="true"><use xlink:href="#icon-blogshouye"></use></svg><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="menu_icon fas fa-music" aria-hidden="true"><use xlink:href="#icon-blogyinle">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/changelog/"><svg class="menu_icon fas fa-changelog" aria-hidden="true"><use xlink:href="#icon-blogguidang">                   </use></svg><span> 更新日志</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="menu_icon fas fa-about" aria-hidden="true"><use xlink:href="#icon-blogguanyuwomen">                   </use></svg><span> 关于</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><svg class="menu_icon fas fa-about" aria-hidden="true"><use xlink:href="#icon-blogmiao">                   </use></svg><span> 文案</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon fas fa-envelope-open" aria-hidden="true"><use xlink:href="#icon-blogliuyanban">                   </use></svg><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/talks/"><i class="fa-fw icon-blogliuyanban"></i><svg class="menu_icon fas fa-envelope-open" aria-hidden="true"><use xlink:href="#icon-blogliuyanban"></use></svg><span> 动态</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-bloglianjie"></i><svg class="menu_icon fas fa-link" aria-hidden="true"><use xlink:href="#icon-bloglianjie"></use></svg><span> 友链</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><!--nav-right--></div><div id="toggleButton"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div><!--随机前往一个文章--><div id="randomPost"><a class="site-page social-icon search" href="javascript:;" onclick="randomPost()" title="随机访问一篇文章"><i class="fas fa-circle-notch fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">赏口饭吃┭┮﹏┭┮</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-15T00:00:00.000Z" title="发表于 2023-03-15 00:00:00">2023-03-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-15T14:00:00.000Z" title="更新于 2023-03-15 14:00:00">2023-03-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%86%B2%E5%86%B2%E5%86%B2/">冲冲冲</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="赏口饭吃┭┮﹏┭┮"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="JavaScript-系列"><a href="#JavaScript-系列" class="headerlink" title="JavaScript 系列"></a>JavaScript 系列</h2><h2 id="JavaScript-中的数据类型-存储差别"><a href="#JavaScript-中的数据类型-存储差别" class="headerlink" title="JavaScript 中的数据类型 存储差别"></a>JavaScript 中的数据类型 存储差别</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 JavaScript 中，我们可以分成两种类型：</p>
<li>基本类型</li>
<li>复杂类型</li>

<p>两种类型的区别是：存储位置不同</p>
<h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h3><p>基本类型主要为以下六种:</p>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Undefined</li>
<li>null</li>
<li>symbol</li>

<p><strong>Number</strong></p>
<p>数值最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x 开头）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span> <span class="comment">// 10进制的55</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">070</span> <span class="comment">// 8进制的56</span></span><br><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xa</span> <span class="comment">//16进制的10</span></span><br></pre></td></tr></table></figure>
<p>浮点类型则在数值汇总必须包含小数点，还可通过科学计数法表示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">let</span> floatNum3 = <span class="number">0.1</span> <span class="comment">// 有效，但不推荐</span></span><br><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span> <span class="comment">// 等于 31250000</span></span><br></pre></td></tr></table></figure>
<p>在数值类型中，存在一个特殊数值 NaN，意为“不是数值”，用于表示本来要返回数值的操作失败了（而不是抛出错误）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> / <span class="number">0</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span> / +<span class="number">0</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p><strong>Undefined</strong></p>
<p><code>Undefined</code>类型只有一个值，就是特殊值 <code>undefined</code>。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 <code>undefined</code>值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>包含<code>undefined</code> 值的变量跟未定义变量是有区别的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message <span class="comment">// 这个变量被声明了，只是值为 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 没有声明过这个变量，报错</span></span><br></pre></td></tr></table></figure>
<p><strong>String</strong></p>
<p>字符串可以使用双引号（”）、单引号（’）或反引号（`）表示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&#x27;John&#x27;</span></span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&#x27;Jacob&#x27;</span></span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">`Jingleheimerschmidt`</span></span><br></pre></td></tr></table></figure>
<p>字符串是不可变的，意思是一旦创建，它们的值就不能变了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&#x27;Java&#x27;</span></span><br><span class="line">lang = lang + <span class="string">&#x27;Script&#x27;</span> <span class="comment">// 先销毁再创</span></span><br></pre></td></tr></table></figure>
<p><strong>Null</strong></p>
<p><code>Null</code>类型同样只有一个值，即特殊值 <code>null</code><br>逻辑上讲， <code>null</code> 值表示一个空对象指针，这也是给<code>typeof</code>传一个 <code>null</code> 会返回 <code>&quot;object&quot;</code> 的原因</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> car) <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>undefined</code> 值是由<code>null</code>值派生而来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>只要变量要保存对象，而当时又没有那个对象可保存，就可用 null 来填充该变量</p>
<p><strong>Boolean</strong></p>
<p><code>Boolean</code>（布尔值）类型有两个字面值： <code>true</code> 和<code>false</code><br>通过<code>Boolean</code>可以将其他类型的数据转化成布尔值<br>规则如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如下：</span><br><span class="line">数据类型      			转换为 <span class="literal">true</span> 的值      	  转换为 <span class="literal">false</span> 的值</span><br><span class="line"> <span class="title class_">String</span>        			 非空字符串     	            <span class="string">&quot;&quot;</span></span><br><span class="line"> <span class="title class_">Number</span> 			非零数值（包括无穷值）  	      <span class="number">0</span> 、 <span class="title class_">NaN</span></span><br><span class="line"> <span class="title class_">Object</span> 			    任意对象 	                 <span class="literal">null</span></span><br><span class="line"><span class="title class_">Undefined</span> 		            N/A （不存在） 	      <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>Symbol</strong><br>Symbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> otherGenericSymbol = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(genericSymbol == otherGenericSymbol) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooSymbol == otherFooSymbol) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2.引用类型"></a>2.引用类型</h3><p>复杂类型统称为<code>Object</code>，我们这里主要讲述下面三种：</p>
<li>Object</li>
<li>Array</li>
<li>Function</li>

<p><strong>Object</strong></p>
<p>创建<code>object</code>常用方式为对象字面量表示法，属性名可以是字符串或数值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Array</strong></p>
<p><code>JavaScript</code>数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。并且，数组也是动态大小的，会随着数据添加而自动增长</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="number">2</span>, &#123; <span class="attr">age</span>: <span class="number">20</span> &#125;]</span><br><span class="line">colors.<span class="title function_">push</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Function</strong></p>
<p>函数实际上是对象，每个函数都是 Function 类型的实例，而 Function 也有属性和方法，跟其他引用类型一样<br>函数存在三种常见的表达方式：</p>
<li>函数声明</li>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<li>函数表达式</li>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span> (<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<li>箭头函数</li>

<p>函数声明和函数表达式两种方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span> (<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上述说的三种之外，还包括 Date、RegExp、Map、Set 。</p>
<h3 id="3-存储区别"><a href="#3-存储区别" class="headerlink" title="3.存储区别"></a>3.存储区别</h3><p>基本数据类型和引用数据类型存储在内存中的位置不同：</p>
<li>基本数据类型存储在栈中</li>
<li>引用类型的对象存储于堆中</li>

<p>当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> b = a <span class="comment">// 赋值操作</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 10值</span></span><br></pre></td></tr></table></figure>
<p>a 的值为一个基本类型，是存储在栈中，将 a 的值赋给 b，虽然两个变量的值相等，但是两个变量保存了两个不同的内存地址<br>下图演示了基本类型赋值的过程:</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="https://static.vue-js.com/906ffb90-6463-11eb-85f6-6fac77c0c9b3.png"/></div></div>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;Xxx&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span>) <span class="comment">// xxx</span></span><br></pre></td></tr></table></figure>
<p>引用类型数据存放在堆中，每个堆内存对象都有对应的引用地址指向它，引用地址存放在栈中。<br><code>obj1</code> 是一个引用类型，在赋值操作过程汇总，实际是将堆内存对象在栈内存的引用地址复制了一份给了 <code>obj2</code>，实际上他们共同指向了同一个堆内存对象，所以更改 <code>obj2</code> 会对 <code>obj1</code> 产生影响</p>
<p>下图演示这个引用类型赋值过程<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://static.vue-js.com/a34bdd10-6463-11eb-ab90-d9ae814b240d.png"/></div></div></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>声明变量时不同的内存地址分配：</p>
<li>简单类型的值存放在栈中，在栈中存放的是对应的值</li>
<li>引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址</li>

<p>不同的数据类型导致赋值变量时的不同</p>
<li>简单类型赋值，是生成相同的值，两个对象对应不同的地址</li>
<li>复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</li>

<h2 id="数组的常用方法有哪些"><a href="#数组的常用方法有哪些" class="headerlink" title="数组的常用方法有哪些"></a>数组的常用方法有哪些</h2><h3 id="1-操作方法"><a href="#1-操作方法" class="headerlink" title="1.操作方法"></a>1.操作方法</h3><p>数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生影响，哪些方法不会</p>
<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响</p>
<li>push()</li>
<li>unshift()</li>
<li>splice()</li>
<li>concat()</li>

<p><strong>push()</strong></p>
<p><code>push()</code>方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [] <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>) <span class="comment">// 推入两项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><strong>unshift()</strong></p>
<p><code>unshift()</code>在数组开头添加任意多个值，然后返回新的数组长度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>() <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">unshift</span>(<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>) <span class="comment">// 从数组开头推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><strong>splice()</strong></p>
<p>传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors) <span class="comment">// red,yellow,orange,green,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p><strong>concat()</strong></p>
<p>首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">&#x27;yellow&#x27;</span>, [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;brown&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors) <span class="comment">// [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2) <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></span><br></pre></td></tr></table></figure>
<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>下面三种都会影响原数组，最后一项不影响原数组：</p>
<li>pop()</li>
<li>shift()</li>
<li>splice()</li>
<li>slice()</li>

<p><strong>pop()</strong></p>
<p><code>pop()</code> 方法用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>() <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// green</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><strong>shift()</strong></p>
<p><code>shift()</code>方法用于删除数组的第一项，同时减少数组的 length 值，返回被删除的项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">shift</span>() <span class="comment">// 取得第一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// red</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><strong>splice()</strong></p>
<p>传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>) <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors) <span class="comment">// green,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed) <span class="comment">// red，只有一个元素的数组</span></span><br></pre></td></tr></table></figure>
<p><strong>slice()</strong></p>
<p><code>slice()</code> 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors) <span class="comment">// red,green,blue,yellow,purple</span></span><br><span class="line">concole.<span class="title function_">log</span>(colors2) <span class="comment">// green,blue,yellow,purple</span></span><br><span class="line">concole.<span class="title function_">log</span>(colors3) <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></table></figure>
<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p>即修改原来数组的内容，常用<code>splice</code></p>
<p><strong>splice()</strong></p>
<p>传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>) <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors) <span class="comment">// red,red,purple,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed) <span class="comment">// green，只有一个元素的数组</span></span><br></pre></td></tr></table></figure>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>即查找元素，返回元素坐标或者元素值</p>
<li>indexOf()</li>
<li>includes()</li>
<li>find()</li>

<p><strong>indexOf()</strong></p>
<p>返回要查找的元素在数组中的位置，如果没找到则返回 -1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><strong>includes()</strong></p>
<p>返回要查找的元素在数组中的位置，找到返回 true，否则 false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">numbers.<span class="title function_">includes</span>(<span class="number">4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>find()</strong></p>
<p>返回第一个匹配的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line">people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>) <span class="comment">// // &#123;name: &quot;Matt&quot;, age: 27&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-排序方法"><a href="#2-排序方法" class="headerlink" title="2.排序方法"></a>2.排序方法</h3><p>数组有两个方法可以用来对元素重新排序：</p>
<li>reverse()</li>
<li>sort()</li>

<p><strong>reverse()</strong></p>
<p>顾名思义，将数组元素方向反转</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">values.<span class="title function_">reverse</span>()</span><br><span class="line"><span class="title function_">alert</span>(values) <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure>
<p><strong>sort()</strong></p>
<p><code>sort()</code>方法接受一个比较函数，用于判断哪个值应该排在前面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]</span><br><span class="line">values.<span class="title function_">sort</span>(compare)</span><br><span class="line"><span class="title function_">alert</span>(values) <span class="comment">// 0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
<h3 id="3-转换方法"><a href="#3-转换方法" class="headerlink" title="3.转换方法"></a>3.转换方法</h3><p>常见的转换方法有：</p>
<p><strong>join()</strong></p>
<p>join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>)) <span class="comment">// red,green,blue</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&#x27;||&#x27;</span>)) <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure>
<h3 id="4-迭代方法"><a href="#4-迭代方法" class="headerlink" title="4.迭代方法"></a>4.迭代方法</h3><p>常用来迭代数组的方法（都不改变原数组）有如下：</p>
<li>some()</li>
<li>every()</li>
<li>forEach()</li>
<li>filter()</li>
<li>map()</li>

<p><strong>some()</strong></p>
<p>对数组每一项都运行传入的测试函数，如果至少有 1 个元素返回 true ，则这个方法返回 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> someResult = numbers.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(someResult) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>every()</strong></p>
<p>对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> everyResult = numbers.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(everyResult) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>forEach()</strong></p>
<p>对数组每一项都运行传入的函数，没有返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>filter()</strong></p>
<p>对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filterResult) <span class="comment">// 3,4,5,4,3</span></span><br></pre></td></tr></table></figure>
<p><strong>map()</strong></p>
<p>对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapResult) <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br></pre></td></tr></table></figure>
<h2 id="JavaScript-中的类型转换机制"><a href="#JavaScript-中的类型转换机制" class="headerlink" title="JavaScript 中的类型转换机制"></a>JavaScript 中的类型转换机制</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>前面我们讲到，JS 中有六种简单数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>string</code>、<code>number</code>、<code>symbol</code>，以及引用类型：<code>object</code><br>但是我们在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = y ? <span class="number">1</span> : a</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>x</code>的值在编译阶段是无法获取的，只有等到程序运行时才能知道<br>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制</p>
<p>常见的类型转换有:</p>
<li>强制转换（显示转换）</li>
<li>自动转换（隐式转换）</li>

<h3 id="2-显示转换"><a href="#2-显示转换" class="headerlink" title="2.显示转换"></a>2.显示转换</h3><p>显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：</p>
<li>Number()</li>
<li>parseInt()</li>
<li>String()</li>
<li>Boolean()</li>

<p><strong>Number()</strong><br>将任意类型的值转化为数值<br>先给出类型转换规则：</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="https://static.vue-js.com/4fafe900-3acc-11eb-85f6-6fac77c0c9b3.png"/></div></div>
<p>实践一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="number">324</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;324&#x27;</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果不可以被解析为数值，返回 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;324abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空字符串转为0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值：true 转成 1，false 转成 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined：转成 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null：转成0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象：通常转换成NaN(除了只包含单个数值的数组)</span></span><br><span class="line"><span class="title class_">Number</span>(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">5</span>]) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>从上面可以看到，Number 转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为 NaN</p>
<p><strong>parseInt()</strong></p>
<p><code>parseInt</code>相比<code>Number</code>，就没那么严格了，<code>parseInt</code>函数逐个解析字符，遇到不能转换的字符就停下来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;32a3&#x27;</span>) <span class="comment">//32</span></span><br></pre></td></tr></table></figure>
<p><strong>String()</strong></p>
<p>可以将任意类型的值转化成字符串,如图所示<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/显示转换string.png"/></div></div></p>
<p>实践一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值：转为相应的字符串</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">1</span>) <span class="comment">// &quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串：转换后还是原来的值</span></span><br><span class="line"><span class="title class_">String</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// &quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//undefined：转为字符串&quot;undefined&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//null：转为字符串&quot;null&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>) <span class="comment">// &quot;null&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="title class_">String</span>(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>Boolean()</strong></p>
<p>可以将任意类型的值转为布尔值，转换规则如下：<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/显示转换Boolean.png"/></div></div></p>
<p>实践一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="title class_">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="3-隐式转换"><a href="#3-隐式转换" class="headerlink" title="3.隐式转换"></a>3.隐式转换</h3><p>在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？</p>
<p>我们这里可以归纳为两种情况发生隐式转换的场景：</p>
<li>比较运算（==、!=、>、<）、if、while需要布尔值地方</li>
<li>算术运算（+、-、*、/、%）</li>

<p>除了上面的场景，还要求运算符两边的操作数不是同一类型</p>
<p><strong>自动转换为布尔值</strong></p>
<p>在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用<code>Boolean</code>函数</p>
<p>可以得出小结:</p>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0</li>
<li>-0</li>
<li>NaN</li>
<li>""</li>

<p>除了上面几种会被转化成<code>false</code>，其他都换被转化成<code>true</code></p>
<p><strong>自动转换为字符串</strong></p>
<p>遇到预期为字符串的地方，就会将非字符串的值自动转为字符串</p>
<p>具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串</p>
<p>常发生在+运算中，一旦存在字符串，则会进行字符串拼接操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="number">1</span> <span class="comment">// &#x27;51&#x27;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">true</span> <span class="comment">// &quot;5true&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">false</span> <span class="comment">// &quot;5false&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + &#123;&#125; <span class="comment">// &quot;5[object Object]&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + [] <span class="comment">// &quot;5&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125; <span class="comment">// &quot;5function ()&#123;&#125;&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">undefined</span> <span class="comment">// &quot;5undefined&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">null</span> <span class="comment">// &quot;5null&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>自动转换为数值</strong></p>
<p>除了<code>+</code>有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;2&#x27;</span> <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * <span class="string">&#x27;2&#x27;</span> <span class="comment">// 10</span></span><br><span class="line"><span class="literal">true</span> - <span class="number">1</span> <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> - <span class="number">1</span> <span class="comment">// -1</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> - <span class="number">1</span> <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * [] <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> / <span class="string">&#x27;5&#x27;</span> <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> - <span class="number">1</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> + <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="number">1</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p><code>null</code>转为数值时，值为<code>0</code> 。<code>undefined</code>转为数值时，值为<code>NaN</code></p>
<h2 id="深拷贝和浅拷贝的区别？如何实现？"><a href="#深拷贝和浅拷贝的区别？如何实现？" class="headerlink" title="深拷贝和浅拷贝的区别？如何实现？"></a>深拷贝和浅拷贝的区别？如何实现？</h2><h3 id="1-数据类型存储"><a href="#1-数据类型存储" class="headerlink" title="1.数据类型存储"></a>1.数据类型存储</h3><p>前面文章我们讲到，<code>JavaScript</code>中存在两大数据类型：1. <code>基本类型</code> 2. <code>引用类型</code></p>
<p>基本类型数据保存在在栈内存中</p>
<p>引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中</p>
<h3 id="2-浅拷贝"><a href="#2-浅拷贝" class="headerlink" title="2.浅拷贝"></a>2.浅拷贝</h3><p>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p>
<p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p>
<p>即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址</p>
<p>下面简单实现一个浅拷贝</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newObj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">      newObj[prop] = obj[prop]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>JavaScript</code>中，存在浅拷贝的现象有：</p>
<li>Object.assign</li>
<li>Array.prototype.slice(), Array.prototype.concat()</li>
<li>使用拓展运算符实现的复制</li>

<p><strong>Object.assign</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">nature</span>: [<span class="string">&#x27;smart&#x27;</span>, <span class="string">&#x27;good&#x27;</span>],</span><br><span class="line">  <span class="attr">names</span>: &#123;</span><br><span class="line">    <span class="attr">name1</span>: <span class="string">&#x27;fx&#x27;</span>,</span><br><span class="line">    <span class="attr">name2</span>: <span class="string">&#x27;xka&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">love</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fx is a great girl&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, fxObj)</span><br></pre></td></tr></table></figure>
<p><strong>slice()</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fxArr = [<span class="string">&#x27;One&#x27;</span>, <span class="string">&#x27;Two&#x27;</span>, <span class="string">&#x27;Three&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> fxArrs = fxArr.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">fxArrs[<span class="number">1</span>] = <span class="string">&#x27;love&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArr) <span class="comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArrs) <span class="comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span></span><br></pre></td></tr></table></figure>
<p><strong>concat()</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fxArr = [<span class="string">&#x27;One&#x27;</span>, <span class="string">&#x27;Two&#x27;</span>, <span class="string">&#x27;Three&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> fxArrs = fxArr.<span class="title function_">concat</span>()</span><br><span class="line">fxArrs[<span class="number">1</span>] = <span class="string">&#x27;love&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArr) <span class="comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArrs) <span class="comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span></span><br></pre></td></tr></table></figure>
<p><strong>拓展运算符</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fxArr = [<span class="string">&#x27;One&#x27;</span>, <span class="string">&#x27;Two&#x27;</span>, <span class="string">&#x27;Three&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> fxArrs = [...fxArr]</span><br><span class="line">fxArrs[<span class="number">1</span>] = <span class="string">&#x27;love&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArr) <span class="comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArrs) <span class="comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span></span><br></pre></td></tr></table></figure>
<h3 id="3-深拷贝"><a href="#3-深拷贝" class="headerlink" title="3.深拷贝"></a>3.深拷贝</h3><p>深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p>
<p>常见的深拷贝方式有：</p>
<li>_.cloneDeep()</li>
<li>jQuery.extend()</li>
<li>JSON.stringify()</li>
<li>手写循环递归</li>

<p><strong>_.cloneDeep()</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">  <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = _.<span class="title function_">cloneDeep</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">f</span> === obj2.<span class="property">b</span>.<span class="property">f</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>jQuery.extend()</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">  <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = $.<span class="title function_">extend</span>(<span class="literal">true</span>, &#123;&#125;, obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">f</span> === obj2.<span class="property">b</span>.<span class="property">f</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>JSON.stringify()</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1))</span><br></pre></td></tr></table></figure>
<p>但是这种方式会存在弊端，会忽略<code>undefined</code>，<code>symbol</code>，<code>函数</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">  <span class="attr">name1</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">name3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="attr">name4</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;A&#x27;</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2) <span class="comment">// &#123;name: &quot;A&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>循环递归</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> obj <span class="comment">// 如果是null或者undefined我就不进行拷贝操作</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj)</span><br><span class="line">  <span class="comment">// 可能是对象或者普通的值  如果是函数的话是不需要深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="comment">// 是对象的话就要进行深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">get</span>(obj)) <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj)</span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>)</span><br><span class="line">  <span class="comment">// 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身</span></span><br><span class="line">  hash.<span class="title function_">set</span>(obj, cloneObj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 实现一个递归拷贝</span></span><br><span class="line">      cloneObj[key] = <span class="title function_">deepClone</span>(obj[key], hash)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-区别"><a href="#4-区别" class="headerlink" title="4.区别"></a>4.区别</h3><p>下面首先借助两张图，可以更加清晰看到浅拷贝与深拷贝的区别</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/深浅区别1.png"/></div></div>
<div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/深浅区别2.png"/></div></div>
<p>从上图发现，浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样</p>
<p>浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;init&#x27;</span>,</span><br><span class="line">  <span class="attr">arr</span>: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj3 = <span class="title function_">shallowClone</span>(obj1) <span class="comment">// 一个浅拷贝方法</span></span><br><span class="line">obj3.<span class="property">name</span> = <span class="string">&#x27;update&#x27;</span></span><br><span class="line">obj3.<span class="property">arr</span>[<span class="number">1</span>] = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] <span class="comment">// 新旧对象还是共享同一块内存</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1&#x27;</span>, obj1) <span class="comment">// obj1 &#123; name: &#x27;init&#x27;,  arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj3&#x27;</span>, obj3) <span class="comment">// obj3 &#123; name: &#x27;update&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br></pre></td></tr></table></figure>
<p>但深拷贝会另外创造一个一模一样的对象，新对象和原对象不共享内存，修改新对象不会改变原对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;init&#x27;</span>,</span><br><span class="line">  <span class="attr">arr</span>: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj4 = <span class="title function_">deepClone</span>(obj1) <span class="comment">// 一个深拷贝方法</span></span><br><span class="line">obj4.<span class="property">name</span> = <span class="string">&#x27;update&#x27;</span></span><br><span class="line">obj4.<span class="property">arr</span>[<span class="number">1</span>] = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] <span class="comment">// 新对象跟原对象不共享内存</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1&#x27;</span>, obj1) <span class="comment">// obj1 &#123; name: &#x27;init&#x27;, arr: [ 1, [ 2, 3 ], 4 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj4&#x27;</span>, obj4) <span class="comment">// obj4 &#123; name: &#x27;update&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>前提为拷贝类型为引用类型的情况下：</p>
<li>浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址</li>
<li>深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</li>

<h2 id="对闭包的理解，使用场景"><a href="#对闭包的理解，使用场景" class="headerlink" title="对闭包的理解，使用场景"></a>对闭包的理解，使用场景</h2><h3 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>一个函数对其周围状态（lexical environment，词法环境）的引用捆绑在一起(或者说函数被引用包围)，这样的组合就是闭包(closure)</p>
<p>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域</p>
<p>在<code>JavaScript</code>中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁<br>下面给出一个简单的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Mozilla&#x27;</span> <span class="comment">// name 是一个被 init 创建的局部变量</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">displayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// displayName() 是内部函数，一个闭包</span></span><br><span class="line">    <span class="title function_">alert</span>(name) <span class="comment">// 使用了父函数中声明的变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">displayName</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">init</span>()</span><br></pre></td></tr></table></figure>
<p><code>displayName()</code> 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量</p>
<h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h3><p>任何闭包的使用场景都离不开这两点:</p>
<li>创建私有变量</li>
<li>延长变量的生命周期</li>

<p></p>

<blockquote><p>一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的</p>
</blockquote>
<p>举个栗子:<br>在页面上添加一些可以调整字号的按钮</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeSizer</span>(<span class="params">size</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = size + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> size12 = <span class="title function_">makeSizer</span>(<span class="number">12</span>)</span><br><span class="line"><span class="keyword">var</span> size14 = <span class="title function_">makeSizer</span>(<span class="number">14</span>)</span><br><span class="line"><span class="keyword">var</span> size16 = <span class="title function_">makeSizer</span>(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;size-12&#x27;</span>).<span class="property">onclick</span> = size12</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;size-14&#x27;</span>).<span class="property">onclick</span> = size14</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;size-16&#x27;</span>).<span class="property">onclick</span> = size16</span><br></pre></td></tr></table></figure>
<p><strong>柯里化函数</strong></p>
<p>柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个求长方形面积的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">width, height</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> width * height</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果我们碰到的长方形的宽老是10</span></span><br><span class="line"><span class="keyword">const</span> area1 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">const</span> area2 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> area3 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以使用闭包柯里化这个计算面积的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">width</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">height</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> width * height</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getTenWidthArea = <span class="title function_">getArea</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 之后碰到宽度为10的长方形就可以这样计算面积</span></span><br><span class="line"><span class="keyword">const</span> area1 = <span class="title function_">getTenWidthArea</span>(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而且如果遇到宽度偶尔变化也可以轻松复用</span></span><br><span class="line"><span class="keyword">const</span> getTwentyWidthArea = <span class="title function_">getArea</span>(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p><strong>使用闭包模拟私有方法</strong></p>
<p>在<code>JavaScript</code>中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法</p>
<p>下面举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Counter</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    privateCounter += val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(-<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Counter1</span> = <span class="title function_">makeCounter</span>()</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Counter2</span> = <span class="title function_">makeCounter</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter1</span>.<span class="title function_">value</span>()) <span class="comment">/* logs 0 */</span></span><br><span class="line"><span class="title class_">Counter1</span>.<span class="title function_">increment</span>()</span><br><span class="line"><span class="title class_">Counter1</span>.<span class="title function_">increment</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter1</span>.<span class="title function_">value</span>()) <span class="comment">/* logs 2 */</span></span><br><span class="line"><span class="title class_">Counter1</span>.<span class="title function_">decrement</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter1</span>.<span class="title function_">value</span>()) <span class="comment">/* logs 1 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter2</span>.<span class="title function_">value</span>()) <span class="comment">/* logs 0 */</span></span><br></pre></td></tr></table></figure>
<p>上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式</p>
<p>两个计数器 <code>Counter1</code> 和 <code>Counter2</code> 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量</p>
<p><strong>其他</strong></p>
<p>例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期</p>
<h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h3><p>如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响</p>
<p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。</p>
<p>原因在于每个对象的创建，方法都会被重新赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name.<span class="title function_">toString</span>()</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message.<span class="title function_">toString</span>()</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getMessage</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name.<span class="title function_">toString</span>()</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message.<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMessage</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对作用域链的理解"><a href="#对作用域链的理解" class="headerlink" title="对作用域链的理解"></a>对作用域链的理解</h2><h3 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h3><p>作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合</p>
<p>换句话说，作用域决定了代码区块中变量和其他资源的可见性</p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> inVariable = <span class="string">&#x27;函数内部变量&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">myFunction</span>() <span class="comment">//要先执行这个函数，否则根本不知道里面是啥</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(inVariable) <span class="comment">// Uncaught ReferenceError: inVariable is not defined</span></span><br></pre></td></tr></table></figure>
<p>上述例子中，函数 myFunction 内部创建一个<code>inVariable</code>变量，当我们在全局访问这个变量的时候，系统会报错</p>
<p>这就说明我们在全局是无法获取到（闭包除外）函数内部的变量</p>
<p>我们一般将作用域分成:</p>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域</li>

<p><strong>全局作用域</strong></p>
<p>任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="title function_">greet</span>()</span><br></pre></td></tr></table></figure>
<p><strong>函数作用域</strong></p>
<p>函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="title function_">greet</span>()</span><br><span class="line"><span class="comment">// 报错： Uncaught ReferenceError: greeting is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting)</span><br></pre></td></tr></table></figure>
<p>可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域</p>
<p><strong>块级作用域</strong></p>
<p>ES6 引入了 let 和 const 关键字,和 var 关键字不同，在大括号中使用 let 和 const 声明的变量存在于块级作用域中。在大括号之外不能访问这些变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 块级作用域中的变量</span></span><br><span class="line">  <span class="keyword">let</span> greeting = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> lang = <span class="string">&#x27;English&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting) <span class="comment">// Prints &#x27;Hello World!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变量 &#x27;English&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lang)</span><br><span class="line"><span class="comment">// 报错：Uncaught ReferenceError: greeting is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting)</span><br></pre></td></tr></table></figure>
<h3 id="2-词法作用域"><a href="#2-词法作用域" class="headerlink" title="2.词法作用域"></a>2.词法作用域</h3><p>词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，JavaScript 遵循的就是词法作用域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">  <span class="title function_">foo</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>()</span><br></pre></td></tr></table></figure>
<p>上述代码变成一张图<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/词法作用域1.png"/></div></div></p>
<p>由于 <code>JavaScript</code> 遵循词法作用域，相同层级的 foo 和 bar 就没有办法访问到彼此块作用域中的变量，所以输出 2</p>
<h3 id="3-作用域链"><a href="#3-作用域链" class="headerlink" title="3.作用域链"></a>3.作用域链</h3><p>当在 Javascript 中使用一个变量的时候，首先 Javascript 引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域</p>
<p>如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错</p>
<p>这里拿《你不知道的 Javascript(上)》中的一张图解释：</p>
<p>把作用域比喻成一个建筑，这份建筑代表程序中的嵌套作用域链，第一层代表当前的执行作用域，顶层代表全局作用域</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/作用域链1.png"/></div></div>
<p>变量的引用会顺着当前楼层进行查找，如果找不到，则会往上一层找，一旦到达顶层，查找的过程都会停止<br>下面代码演示下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sex = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">student</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// 张三</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(sex) <span class="comment">// 男</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">student</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// Uncaught ReferenceError: age is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">person</span>()</span><br></pre></td></tr></table></figure>
<p>上述代码主要主要做了以下工作：</p>
<li>student函数内部属于最内层作用域，找不到name，向上一层作用域person函数内部找，找到了输出“张三”</li>
<li>student内部输出sex时找不到，向上一层作用域person函数找，还找不到继续向上一层找，即全局作用域，找到了输出“男”</li>
<li>在person函数内部输出age时找不到，向上一层作用域找，即全局作用域，还是找不到则报错</li>

<h2 id="JavaScript-原型，原型链，有什么特点"><a href="#JavaScript-原型，原型链，有什么特点" class="headerlink" title="JavaScript 原型，原型链，有什么特点"></a>JavaScript 原型，原型链，有什么特点</h2><h3 id="1-原型"><a href="#1-原型" class="headerlink" title="1.原型"></a>1.原型</h3><p><code>JavaScript</code>常被描述为一种基于原型的语言——每个对象拥有一个原型对象</p>
<p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p>
<p>准确地说，这些属性和方法定义在 Object 的构造器函数（constructor functions）之上的 prototype 属性上，而非实例对象本身</p>
<p>下面举个例子： 函数可以有属性。 每个函数都有一个特殊的属性叫作原型 <code>prototype</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doSomething.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure>
<p>控制台输出:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">constructor</span>: ƒ <span class="title function_">doSomething</span>(),</span><br><span class="line">    <span class="attr">__proto__</span>: &#123;</span><br><span class="line">        <span class="attr">constructor</span>: ƒ <span class="title class_">Object</span>(),</span><br><span class="line">        <span class="attr">hasOwnProperty</span>: ƒ <span class="title function_">hasOwnProperty</span>(),</span><br><span class="line">        <span class="attr">isPrototypeOf</span>: ƒ <span class="title function_">isPrototypeOf</span>(),</span><br><span class="line">        <span class="attr">propertyIsEnumerable</span>: ƒ <span class="title function_">propertyIsEnumerable</span>(),</span><br><span class="line">        <span class="attr">toLocaleString</span>: ƒ <span class="title function_">toLocaleString</span>(),</span><br><span class="line">        <span class="attr">toString</span>: ƒ <span class="title function_">toString</span>(),</span><br><span class="line">        <span class="attr">valueOf</span>: ƒ <span class="title function_">valueOf</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个对象，就是大家常说的原型对象<br>可以看到，原型对象有一个自有属性<code>constructor</code>，这个属性指向该函数，如下图关系展示<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/原型.png"/></div></div></p>
<h3 id="2-原型链"><a href="#2-原型链" class="headerlink" title="2.原型链"></a>2.原型链</h3><p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法</p>
<p>在对象实例和它的构造器之间建立一个链接（它是<strong>proto</strong>属性，是从构造函数的 prototype 属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法</p>
<p>下面举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二步 创建实例</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>根据代码，我们可以得到下图<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/原型链1.png"/></div></div></p>
<p>下面分析一下：</p>
<li>构造函数Person存在原型对象Person.prototype</li>
<li>构造函数生成实例对象person，person的__proto__指向构造函数Person原型对象</li>
<li>Person.prototype.__proto__ 指向内置对象，因为 Person.prototype 是个对象，默认是由 Object函数作为类创建的，而 Object.prototype 为内置对象</li>
<li>Person.__proto__ 指向内置匿名函数 anonymous，因为 Person 是个函数对象，默认由 Function 作为类创建</li>
<li>Function.prototype 和 Function.__proto__同时指向内置匿名函数 anonymous，这样原型链的终点就是 null</li>

<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>下面首先要看几个概念：</p>
<p><code>__proto__</code>作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/原型链2.png"/></div></div></p>
<p>每个对象的<code>__proto__</code>都是指向它的构造函数的原型对象<code>prototype</code>的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>
<p>构造函数是一个函数对象，是通过 <code>Function</code>构造器产生的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>
<p>原型对象本身是一个普通对象，而普通对象的构造函数都是<code>Object</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>
<p>刚刚上面说了，所有的构造器都是函数对象，函数对象都是 <code>Function</code>构造产生的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>
<p><code>Object</code>的原型对象也有<code>__proto__</code>属性指向<code>null</code>，<code>null</code>是原型链的顶端</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>下面做出总结:</p>
<li>一切对象都是继承自Object对象，Object 对象直接继承根源对象null</li>
<li>一切的函数对象（包括 Object 对象），都是继承自 Function 对象</li>
<li>Object 对象直接继承自 Function 对象</li>
<li>Function对象的__proto__会指向自己的原型对象，最终还是继承自Object对象</li>

<h2 id="JavaScript-怎么实现继承"><a href="#JavaScript-怎么实现继承" class="headerlink" title="JavaScript 怎么实现继承"></a>JavaScript 怎么实现继承</h2><h3 id="1-是什么-1"><a href="#1-是什么-1" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>继承（inheritance）是面向对象软件技术当中的一个概念。<br>如果一个类别 B“继承自”另一个类别 A，就把这个 B 称为“A 的子类”，而把 A 称为“B 的父类别”也可以称“A 是 B 的超类”</p>
<p>继承的优点:</p>
<li>继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码</li>
<li>在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能</li>

<p>虽然<code>JavaScript</code>并不是真正的面向对象语言，但它天生的灵活性，使应用场景更加丰富</p>
<p>关于继承，我们举个形象的例子：</p>
<p>定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">color, speed</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = speed</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由汽车这个类可以派生出“轿车”和“货车”两个类，在汽车的基础属性上，为轿车添加一个后备厢、给货车添加一个大货箱</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 货车</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Truck</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">color, speed</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(color, speed)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Container</span> = <span class="literal">true</span> <span class="comment">// 货箱</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样轿车和货车就是不一样的，但是二者都属于汽车这个类，汽车、轿车继承了汽车的属性，而不需要再次在“轿车”中定义汽车已经有的属性</p>
<p>在“轿车”继承“汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与“汽车”这个父类不同的属性和方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Truck</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">color, speed</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(color, speed)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&#x27;black&#x27;</span> <span class="comment">//覆盖</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Container</span> = <span class="literal">true</span> <span class="comment">// 货箱</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个例子中就能详细说明汽车、轿车以及卡车之间的继承关系</p>
<h3 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2.实现方式"></a>2.实现方式</h3><p>下面给出<code>JavaScripy</code>常见的继承方式:</p>
<li>原型链继承</li>
<li>构造函数继承（借助 call）</li>
<li>组合继承</li>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>

<p><strong>原型链继承</strong></p>
<p>原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent1&#x27;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child1</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child</span>())</span><br></pre></td></tr></table></figure>
<p>上面代码看似没问题，实际存在潜在问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">Child2</span>()</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="title class_">Child2</span>()</span><br><span class="line">s1.<span class="property">play</span>.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">play</span>, s2.<span class="property">play</span>) <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<p>改变 s1 的 play 属性，会发现 s2 也跟着发生变化了，这是因为两个实例使用的是同一个原型对象，内存空间是共享的</p>
<p><strong>构造函数继承</strong></p>
<p>借助 <code>call</code>调用<code>Parent</code>函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child) <span class="comment">// 没问题</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="title function_">getName</span>()) <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure>
<p>可以看到，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法</p>
<p>相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法</p>
<p><strong>组合继承</strong><br>前面我们讲到两种继承方式，各有优缺点。组合继承则将前两种方式继承起来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent3&#x27;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent3</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 第二次调用 Parent3()</span></span><br><span class="line">  <span class="title class_">Parent3</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用 Parent3()</span></span><br><span class="line"><span class="title class_">Child3</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent3</span>()</span><br><span class="line"><span class="comment">// 手动挂上构造器，指向自己的构造函数</span></span><br><span class="line"><span class="title class_">Child3</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child3</span></span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> <span class="title class_">Child3</span>()</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> <span class="title class_">Child3</span>()</span><br><span class="line">s3.<span class="property">play</span>.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3.<span class="property">play</span>, s4.<span class="property">play</span>) <span class="comment">// 不互相影响</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3.<span class="title function_">getName</span>()) <span class="comment">// 正常输出&#x27;parent3&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s4.<span class="title function_">getName</span>()) <span class="comment">// 正常输出&#x27;parent3&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到<code>Parent3</code> 执行了两次，造成了多构造一次的性能开销</p>
<p><strong>原型式继承</strong></p>
<p>这里主要借助<code>Object.create</code>方法实现普通对象的继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parent4 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;parent4&#x27;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&#x27;p1&#x27;</span>, <span class="string">&#x27;p2&#x27;</span>, <span class="string">&#x27;p3&#x27;</span>],</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person4 = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent4)</span><br><span class="line">person4.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">person4.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;jerry&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person5 = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent4)</span><br><span class="line">person5.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;lucy&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person4.<span class="property">name</span>) <span class="comment">// tom</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person4.<span class="property">name</span> === person4.<span class="title function_">getName</span>()) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person5.<span class="property">name</span>) <span class="comment">// parent4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person4.<span class="property">friends</span>) <span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person5.<span class="property">friends</span>) <span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span></span><br></pre></td></tr></table></figure>
<p>这种继承方式的缺点也很明显，因为<code>Object.create</code>方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能</p>
<p><strong>寄生式继承</strong></p>
<p>寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parent5 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;parent5&#x27;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&#x27;p1&#x27;</span>, <span class="string">&#x27;p2&#x27;</span>, <span class="string">&#x27;p3&#x27;</span>],</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">original</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(original)</span><br><span class="line">  clone.<span class="property">getFriends</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">friends</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person5 = <span class="title function_">clone</span>(parent5)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person5.<span class="title function_">getName</span>()) <span class="comment">// parent5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person5.<span class="title function_">getFriends</span>()) <span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;]</span></span><br></pre></td></tr></table></figure>
<p>其优缺点也很明显，跟上面讲的原型式继承一样</p>
<p><strong>寄生组合式继承</strong></p>
<p>寄生组合式继承，借助解决普通对象的继承问题的<code>Object.create</code>方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">parent, child</span>) &#123;</span><br><span class="line">  <span class="comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span></span><br><span class="line">  child.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  child.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = child</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent6</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent6&#x27;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent6</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child6</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent6</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = <span class="string">&#x27;child5&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">clone</span>(<span class="title class_">Parent6</span>, <span class="title class_">Child6</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child6</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getFriends</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">friends</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person6 = <span class="keyword">new</span> <span class="title class_">Child6</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person6) <span class="comment">//&#123;friends:&quot;child5&quot;,name:&quot;child5&quot;,play:[1,2,3],__proto__:Parent6&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person6.<span class="title function_">getName</span>()) <span class="comment">// parent6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person6.<span class="title function_">getFriends</span>()) <span class="comment">// child5</span></span><br></pre></td></tr></table></figure>
<p>可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题<br>文章一开头，我们是使用 ES6 中的<code>extends</code>关键字直接实现 <code>JavaScript</code>的继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 原型方法</span></span><br><span class="line">  <span class="comment">// 即 Person.prototype.getName = function() &#123; &#125;</span></span><br><span class="line">  <span class="comment">// 下面可以简写为 getName() &#123;...&#125;</span></span><br><span class="line">  getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gamer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> asuna = <span class="keyword">new</span> <span class="title class_">Gamer</span>(<span class="string">&#x27;Asuna&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">asuna.<span class="title function_">getName</span>() <span class="comment">// 成功访问到父类的方法</span></span><br></pre></td></tr></table></figure>
<p>利用<code>babel</code>工具进行转换，我们会发现 extends`实际采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式</p>
<h3 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3.总结"></a>3.总结</h3><p>下面一张图<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/继承总结1.png"/></div></div><br>通过<code>Object.create</code> 来划分不同的继承方式，最后的寄生式组合继承方式是通过组合继承改造之后的最优继承方式，而 extends 的语法糖和寄生组合继承的方式基本类似</p>
<h2 id="谈谈-this-对象的理解"><a href="#谈谈-this-对象的理解" class="headerlink" title="谈谈 this 对象的理解"></a>谈谈 this 对象的理解</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>函数的 <code>this</code> 关键字在 <code>JavaScript</code>中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别<br>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值（运行时绑定）</p>
<p><code>this</code>关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 当前调用栈是：baz</span></span><br><span class="line">  <span class="comment">// 因此，当前调用位置是全局作用域</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>)</span><br><span class="line">  <span class="title function_">bar</span>() <span class="comment">// &lt;-- bar的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 当前调用栈是：baz --&gt; bar</span></span><br><span class="line">  <span class="comment">// 因此，当前调用位置在baz中</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">  <span class="title function_">foo</span>() <span class="comment">// &lt;-- foo的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 当前调用栈是：baz --&gt; bar --&gt; foo</span></span><br><span class="line">  <span class="comment">// 因此，当前调用位置在bar中</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">baz</span>() <span class="comment">// &lt;-- baz的调用位置</span></span><br></pre></td></tr></table></figure>
<p>同时，<code>this</code>在函数执行过程中，<code>this</code>一旦被确定了，就不可以再更改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span> = obj; <span class="comment">// 修改this，运行后会报错</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>
<h3 id="2-绑定规则"><a href="#2-绑定规则" class="headerlink" title="2.绑定规则"></a>2.绑定规则</h3><p>根据不同的使用场合，this 有不同的值，主要分为下面几种情况：</p>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>new绑定</li>
<li>显示绑定</li>

<h3 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3.箭头函数"></a>3.箭头函数</h3><p>在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 this 的指向（编译时绑定）<br>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">sayThis</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">sayThis</span>() <span class="comment">// window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了</span></span><br><span class="line"><span class="keyword">const</span> globalSay = obj.<span class="property">sayThis</span></span><br><span class="line"><span class="title function_">globalSay</span>() <span class="comment">// window 浏览器中的 global 对象</span></span><br></pre></td></tr></table></figure>
<p>虽然箭头函数的 this 能够在编译的时候就确定了 this 的指向，但也需要注意一些潜在的坑</p>
<p>下面举个例子：</p>
<p>绑定事件监听</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mngb&#x27;</span>)</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;clicked button&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上述可以看到，我们其实是想要<code>this</code>为点击的<code>button</code>，但此时<code>this</code>指向了<code>window</code></p>
<p>包括在原型上添加方法时候，此时<code>this</code>指向<code>window</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">//true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;mm&#x27;</span>)</span><br><span class="line">cat.<span class="title function_">sayName</span>()</span><br></pre></td></tr></table></figure>
<p>同样的，箭头函数不能作为构建函数</p>
<h3 id="4-优先级"><a href="#4-优先级" class="headerlink" title="4.优先级"></a>4.优先级</h3><h4 id="隐式绑定-VS-显示绑定"><a href="#隐式绑定-VS-显示绑定" class="headerlink" title="隐式绑定 VS 显示绑定"></a>隐式绑定 VS 显示绑定</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>() <span class="comment">// 2</span></span><br><span class="line">obj2.<span class="title function_">foo</span>() <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>(obj2) <span class="comment">// 3</span></span><br><span class="line">obj2.<span class="property">foo</span>.<span class="title function_">call</span>(obj1) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>显然，显示绑定的优先级更高</p>
<h4 id="new-绑定-VS-隐式绑定"><a href="#new-绑定-VS-隐式绑定" class="headerlink" title="new 绑定 VS 隐式绑定"></a>new 绑定 VS 隐式绑定</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>(obj2, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.<span class="title function_">foo</span>(<span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">a</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>可以看到，new 绑定的优先级&gt;隐式绑定</p>
<h4 id="new-绑定-VS-显式绑定"><a href="#new-绑定-VS-显式绑定" class="headerlink" title="new 绑定 VS 显式绑定"></a>new 绑定 VS 显式绑定</h4><p>因为<code>new</code>和<code>apply</code>、<code>call</code>无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj1)</span><br><span class="line"><span class="title function_">bar</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>(<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">a</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><code>bar</code>被绑定到 obj1 上，但是<code>new bar(3)</code> 并没有像我们预计的那样把<code>obj1.a</code>修改为 3。但是，<code>new</code>修改了绑定调用<code>bar()</code>中的<code>this</code></p>
<p>我们可认为<code>new</code>绑定优先级&gt;显式绑定</p>
<p>综上，new 绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p>
<h2 id="JavaScript-中执行上下文和执行栈"><a href="#JavaScript-中执行上下文和执行栈" class="headerlink" title="JavaScript 中执行上下文和执行栈"></a>JavaScript 中执行上下文和执行栈</h2><h2 id="JavaScript-事件模型"><a href="#JavaScript-事件模型" class="headerlink" title="JavaScript 事件模型"></a>JavaScript 事件模型</h2><h3 id="1-事件与事件流"><a href="#1-事件与事件流" class="headerlink" title="1.事件与事件流"></a>1.事件与事件流</h3><p><code>javascript</code>中的事件，可以理解就是在 HTML 文档或者浏览器中发生的一种交互操作，使得网页具备互动性， 常见的有加载事件、鼠标事件、自定义事件等</p>
<p>由于 DOM 是一个树结构，如果在父子节点绑定事件时候，当触发子节点的时候，就存在一个顺序问题，这就涉及到了事件流的概念</p>
<p>事件流都会经历三个阶段:</p>
<li>事件捕获阶段(capture phase)</li>
<li>处于目标阶段(target phase)</li>
<li>事件冒泡阶段(bubbling phase)</li>

<div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/事件流1.png"/></div></div>
<p>事件冒泡是一种从下往上的传播方式，由最具体的元素（触发节点）然后逐渐向上传播到最不具体的那个节点，也就是 DOM 中最高层的父节点</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;clickMe&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，我们给<code>button</code>和它的父元素，加入点击事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;clickMe&#x27;</span>)</span><br><span class="line"></span><br><span class="line">button.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1.Button&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2.body&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3.document&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4.window&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击按钮输出如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>button</span><br><span class="line"><span class="number">2.</span>body</span><br><span class="line"><span class="number">3.</span><span class="variable language_">document</span></span><br><span class="line"><span class="number">4.</span><span class="variable language_">window</span></span><br></pre></td></tr></table></figure>
<p>点击事件首先在<code>button</code>元素上发生，然后逐级向上传播</p>
<p>事件捕获与事件冒泡相反，事件最开始由不太具体的节点最早接受事件, 而最具体的节点（触发节点）最后接受事件</p>
<h3 id="2-事件模型"><a href="#2-事件模型" class="headerlink" title="2.事件模型"></a>2.事件模型</h3><p>事件模型可以分为三种:</p>
<li>原始事件模型（DOM0级）</li>
<li>标准事件模型（DOM2级）</li>
<li>IE事件模型（基本不用）</li>

<p><strong>原始事件模型</strong></p>
<p>事件绑定监听函数比较简单，有两种方式:</p>
<p>HTML 代码直接绑定</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;fun()&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>通过 JS 代码绑定</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line">btn.<span class="property">onclick</span> = fun</span><br></pre></td></tr></table></figure>
<p><strong>特性</strong></p>
<li>绑定速度快</li>
DOM0级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行
<li>只支持冒泡，不支持捕获</li>
<li>同一个类型的事件只能绑定一次</li>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn&quot;</span> onclick=<span class="string">&quot;fun1()&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = fun2;</span><br></pre></td></tr></table></figure>
<p>如上，当希望为同一个元素绑定多个同类型事件的时候（上面的这个 btn 元素绑定 2 个点击事件），是不被允许的，后绑定的事件会覆盖之前的事件</p>
<p>删除 DOM0 级事件处理程序只要将对应事件属性置为 null 即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p><strong>标准事件模型</strong><br>在该事件模型中，一次事件共有三个过程:</p>
<li>事件捕获阶段：事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>
<li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数</li>
<li>事件冒泡阶段：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>

<p>事件监听函数的方式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure>
<p>事件移除监听函数的方式如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">removeEventListener</span>(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure>
<p>参数如下:</p>
<li>eventType指定事件类型(不要加on)</li>
<li>handler是事件处理函数</li>
<li>useCapture是一个boolean用于指定是否在捕获阶段进行处理，一般设置为false与IE浏览器保持一致</li>

<p>举个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(‘click’, showMessage, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p><strong>特性</strong><br>可以在一个 DOM 元素上绑定多个事件处理器，各自并不会冲突</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage1, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage2, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage3, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>执行时机</p>
<p>当第三个参数(<code>useCapture</code>)设置为 true 就在捕获过程中执行，反之在冒泡过程中执行处理函数</p>
<p>下面举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;div&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;span&quot;</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>设置点击事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onClickFn</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> tagName = event.<span class="property">currentTarget</span>.<span class="property">tagName</span></span><br><span class="line">  <span class="keyword">var</span> phase = event.<span class="property">eventPhase</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tagName, phase)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">false</span>)</span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>上述使用了<code>eventPhase</code>，返回一个代表当前执行阶段的整数值。1 为捕获阶段、2 为事件对象触发阶段、3 为冒泡阶段</p>
<p>点击<code>Click Me!</code>，输出如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P <span class="number">3</span></span><br><span class="line"><span class="variable constant_">DIV</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>p</code>和<code>div</code>都是在冒泡阶段响应了事件，由于冒泡的特性，裹在里层的 p 率先做出响应</p>
<p>如果把第三个参数都改为<code>true</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">true</span>)</span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DIV</span> <span class="number">1</span></span><br><span class="line">P <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>两者都是在捕获阶段响应事件，所以 div 比 p 标签先做出响应</p>
<h2 id="typeof-与-instanceof-的区别"><a href="#typeof-与-instanceof-的区别" class="headerlink" title="typeof 与 instanceof 的区别"></a>typeof 与 instanceof 的区别</h2><h3 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h3><p><code>typeof</code>操作符返回一个字符串，表示未经计算的操作数的类型<br>使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> operand</span><br><span class="line"><span class="keyword">typeof</span> operand</span><br></pre></td></tr></table></figure>
<p><code>operand</code>表示对象或原始值的表达式，其类型将被返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="property">log</span> <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>
<p>从上面例子，前 6 个都是基础数据类型。虽然<code>typeof null</code>为<code>object</code>，但这只是<code>JavaScript</code> 存在的一个悠久 Bug，不代表 null 就是引用数据类型，并且 null 本身也不是对象</p>
<p>所以，<code>null</code>在 <code>typeof</code>之后返回的是有问题的结果，不能作为判断 null 的方法。如果你需要在 if 语句中判断是否为 <code>null</code>，直接通过<code>===null</code>来判断就好</p>
<p>同时，可以发现引用类型数据，用<code>typeof</code>来判断的话，除了<code>function</code>会被识别出来之外，其余的都输出<code>object</code></p>
<p>如果我们想要判断一个变量是否存在，可以使用<code>typeof</code>：(不能使用 if(a)， 若 a 未声明，则报错)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">//变量存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h3><p><code>instanceof</code>运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上,使用如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> constructor</span><br></pre></td></tr></table></figure>
<p><code>object</code>为实例对象，<code>constructor</code>为构造函数</p>
<p>构造函数通过<code>new</code>可以实例对象，<code>instanceof</code>能判断这个对象是否是之前那个构造函数生成的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构建函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Car</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> benz = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line">benz <span class="keyword">instanceof</span> <span class="title class_">Car</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">car <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">str <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>关于<code>instanceof</code>的实现原理，可以参考下面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="comment">// 这里先用typeof来判断基础数据类型，如果是，直接返回false</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> left !== <span class="string">&#x27;object&#x27;</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">// getProtypeOf是Object对象自带的API，能够拿到参数的原型对象</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left)</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (proto === right.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">//找到相同原型对象，返回true</span></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeof</span>(proto)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">;<span class="string">``</span></span><br></pre></td></tr></table></figure>
<h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><p><code>typeof</code>与<code>instanceof</code>都是判断数据类型的方法，区别如下：</p>
<li>typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值</li>
<li>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</li>
<li>而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断</li>

<p>可以看到，上述两种方法都有弊端，并不能满足所有场景的需求</p>
<p>如果需要通用检测数据类型，可以采用<code>Object.prototype.toString</code>，调用该方法，统一返回格式“<code>[object Xxx]</code>”的字符串<br>如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>(&#123;&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;) <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>) <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;1&#x27;</span>) <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>) <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;) <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">//&quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">//&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/123/g</span>) <span class="comment">//&quot;[object RegExp]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">//&quot;[object Date]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) <span class="comment">//&quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="variable language_">document</span>) <span class="comment">//&quot;[object HTMLDocument]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="variable language_">window</span>) <span class="comment">//&quot;[object Window]&quot;</span></span><br></pre></td></tr></table></figure>
<p>了解了 toString 的基本用法，下面就实现一个全局通用的数据类型判断方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj</span><br><span class="line">  <span class="keyword">if</span> (type !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 先进行typeof判断，如果是基础数据类型，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> type</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">replace</span>(<span class="regexp">/^\[object (\S+)\]$/</span>, <span class="string">&#x27;$1&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getType</span>([]) <span class="comment">// &quot;Array&quot; typeof []是object，因此toString返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// &quot;string&quot; typeof 直接返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="variable language_">window</span>) <span class="comment">// &quot;Window&quot; toString返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="literal">null</span>) <span class="comment">// &quot;Null&quot;首字母大写，typeof null是object，需toString来判断</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line"><span class="title function_">getType</span>() <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;) <span class="comment">// &quot;function&quot; typeof能判断，因此首字母小写</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="regexp">/123/g</span>) <span class="comment">//&quot;RegExp&quot; toString返回</span></span><br></pre></td></tr></table></figure>
<h2 id="什么是事件代理？应用场景"><a href="#什么是事件代理？应用场景" class="headerlink" title="什么是事件代理？应用场景"></a>什么是事件代理？应用场景</h2><h3 id="1-是什么-2"><a href="#1-是什么-2" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>事件代理，俗地来讲，就是把一个元素响应事件（<code>click</code>、<code>keydown</code>……）的函数委托到另一个元素</p>
<p>前面讲到，事件流的都会经过三个阶段： 捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段，而事件委托就是在冒泡阶段完成</p>
<p>事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素</p>
<p>当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数</p>
<p>下面举个例子：</p>
<p>比如一个宿舍的同学同时快递到了，一种笨方法就是他们一个个去领取</p>
<p>较优方法就是把这件事情委托给宿舍长，让一个人出去拿好所有快递，然后再根据收件人一一分发给每个同学</p>
<p>在这里，取快递就是一个事件，每个同学指的是需要响应事件的 <code>DOM</code> 元素，而出去统一领取快递的宿舍长就是代理的元素</p>
<p>所以真正绑定事件的是这个元素，按照收件人分发快递的过程就是在事件执行中，需要判断当前响应的事件应该匹配到被代理元素中的哪一个或者哪几个</p>
<h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2.应用场景"></a>2.应用场景</h3><p>如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  ......</span><br><span class="line">  &lt;li&gt;item n&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素</span></span><br><span class="line"><span class="keyword">const</span> lis = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"><span class="comment">// 循环遍历绑定事件</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lis.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  lis[i].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">innerHTML</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候就可以事件委托，把点击事件绑定在父级元素 ul 上面，然后执行事件的时候再去匹配目标元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给父层元素绑定事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 兼容性处理</span></span><br><span class="line">  <span class="keyword">var</span> event = e || <span class="variable language_">window</span>.<span class="property">event</span></span><br><span class="line">  <span class="keyword">var</span> target = event.<span class="property">target</span> || event.<span class="property">srcElement</span></span><br><span class="line">  <span class="comment">// 判断是否匹配目标元素</span></span><br><span class="line">  <span class="keyword">if</span> (target.<span class="property">nodeName</span>.<span class="property">toLocaleLowerCase</span> === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;the content is: &#x27;</span>, target.<span class="property">innerHTML</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>还有一种场景是上述列表项并不多，我们给每个列表项都绑定了事件</p>
<p>但是如果用户能够随时动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件</p>
<p>如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的</p>
<p>举个例子:<br>下面<code>html</code>结构中，点击<code>input</code>可以动态添加元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用事件委托</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> oUl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ul1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> num = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//事件委托，添加的子元素也有事件</span></span><br><span class="line">oUl.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line">  ev = ev || <span class="variable language_">window</span>.<span class="property">event</span></span><br><span class="line">  <span class="keyword">const</span> target = ev.<span class="property">target</span> || ev.<span class="property">srcElement</span></span><br><span class="line">  <span class="keyword">if</span> (target.<span class="property">nodeName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;the content is: &#x27;</span>, target.<span class="property">innerHTML</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加新节点</span></span><br><span class="line">oBtn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  num++</span><br><span class="line">  <span class="keyword">const</span> oLi = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">  oLi.<span class="property">innerHTML</span> = <span class="string">`item <span class="subst">$&#123;num&#125;</span>`</span></span><br><span class="line">  oUl.<span class="title function_">appendChild</span>(oLi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，使用事件委托，在动态绑定事件的情况下是可以减少很多重复工作的</p>
<h3 id="3-总结-2"><a href="#3-总结-2" class="headerlink" title="3.总结"></a>3.总结</h3><p>适合事件委托的事件有：<code>click</code>，<code>mousedown</code>，<code>mouseup</code>，<code>keydown</code>，<code>keyup</code>，<code>keypress</code><br>从上面应用场景中，我们就可以看到使用事件委托存在两大优点：</p>
<li>减少整个页面所需的内存，提升整体性能</li>
<li>动态绑定，减少重复工作</li>

<p>但是使用事件委托也是存在局限性：</p>
<li>focus、blur这些事件没有事件冒泡机制，所以无法进行委托绑定事件</li>
<li>mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的</li>

<p>如果把所有事件都用事件代理，可能会出现事件误判，即本不该被触发的事件被绑定上了事件</p>
<h2 id="new-操作符具体干了什么"><a href="#new-操作符具体干了什么" class="headerlink" title="new 操作符具体干了什么"></a>new 操作符具体干了什么</h2><h3 id="1-是什么-3"><a href="#1-是什么-3" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>在<code>JavaScript</code>中，new 操作符用于创建一个给定构造函数的实例对象</p>
<p>例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1) <span class="comment">// Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span></span><br><span class="line">t.<span class="title function_">sayName</span>() <span class="comment">// &#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure>
<p>从上面可以看到：</p>
<li>new 通过构造函数 Person 创建出来的实例可以访问到构造函数中的属性</li>
<li>new 通过构造函数 Person 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来）</li>

<p>现在在构建函数中显式加上返回值，并且这个返回值是一个原始类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="property">name</span>) <span class="comment">// &#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以发现,构造函数中返回一个原始值，然而这个返回值并没有作用</p>
<p>下面在构造函数中返回一个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// Test &#123; name: &#x27;xxx&#x27; &#125;</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">age</span>: <span class="number">26</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t) <span class="comment">// &#123; age: 26 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="property">name</span>) <span class="comment">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>
<p>从上面可以发现，构造函数如果返回值为一个对象，那么这个返回值会被正常使用</p>
<h3 id="2-流程"><a href="#2-流程" class="headerlink" title="2.流程"></a>2.流程</h3><p>从上面介绍中，我们可以看到 new 关键字主要做了以下的工作：</p>
<li>创建一个新的对象 obj</li>
<li>将对象与构建函数通过原型链连接起来</li>
<li>将构建函数中的 this 绑定到新建的对象 obj 上</li>
<li>根据构建函数返回类型做判断，如果返回类型原始值则被忽略，如果返回的是对象，则正常处理</li>

<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1) <span class="comment">// Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span></span><br><span class="line">t.<span class="title function_">sayName</span>() <span class="comment">// &#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure>
<p>流程图如下:<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/new1.png"/></div></div></p>
<h3 id="3-手写-new-操作符"><a href="#3-手写-new-操作符" class="headerlink" title="3.手写 new 操作符"></a>3.手写 new 操作符</h3><p>现在我们已经清楚地掌握了<code>new</code>的执行过程</p>
<p>那么我们就动手来实现一下<code>new</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mynew</span>(<span class="params">Func, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.创建一个新对象</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="comment">// 2.新对象原型指向构造函数原型对象</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="comment">// 3.将构建函数的this指向新对象</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="title class_">Func</span>.<span class="title function_">apply</span>(obj, args)</span><br><span class="line">  <span class="comment">// 4.根据返回值判断</span></span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mynew</span>(<span class="params">func, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  obj.<span class="property">__proto__</span> = func.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="keyword">let</span> result = func.<span class="title function_">apply</span>(obj, args)</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="title function_">mynew</span>(<span class="title class_">Person</span>, <span class="string">&#x27;huihui&#x27;</span>, <span class="number">123</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p) <span class="comment">// Person &#123;name: &quot;huihui&quot;, age: 123&#125;</span></span><br><span class="line">p.<span class="title function_">say</span>() <span class="comment">// huihui</span></span><br></pre></td></tr></table></figure>
<p>可以发现 代码虽然短 但是能够模拟实现 <code>new</code></p>
<h2 id="ajax-原理是什么？如何实现"><a href="#ajax-原理是什么？如何实现" class="headerlink" title="ajax 原理是什么？如何实现"></a>ajax 原理是什么？如何实现</h2><h3 id="1-是什么-4"><a href="#1-是什么-4" class="headerlink" title="1.是什么"></a>1.是什么</h3><p><code>AJAX</code>全称(Async Javascript and XML)</p>
<p>即异步的<code>JavaScript</code> 和<code>XML</code>，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页</p>
<p><code>Ajax</code>的原理简单来说通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>JavaScript</code>来操作<code>DOM</code>而更新页面</p>
<p>流程图如下:<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/ajax1.png"/></div></div></p>
<p>下面举个例子:<br>领导想找小李汇报一下工作，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作</p>
<p>Ajax 请求数据流程与“领导想找小李汇报一下工作”类似，上述秘书就相当于 XMLHttpRequest 对象，领导相当于浏览器，响应数据相当于小李</p>
<p>浏览器可以发送 HTTP 请求后，接着做其他事情，等收到 XHR 返回来的数据再进行操作</p>
<h3 id="2-实现过程"><a href="#2-实现过程" class="headerlink" title="2.实现过程"></a>2.实现过程</h3><p>实现 <code>Ajax</code>异步交互需要服务器逻辑进行配合，需要完成以下步骤：</p>
<li>创建 Ajax的核心对象 XMLHttpRequest对象</li>
<li>通过 XMLHttpRequest 对象的 open() 方法与服务端建立连接</li>
<li>构建请求所需的数据内容，并通过XMLHttpRequest 对象的 send() 方法发送给服务器端</li>
<li>通过 XMLHttpRequest 对象提供的 onreadystatechange 事件监听服务器端你的通信状态</li>
<li>接受并处理服务端向客户端响应的数据结果</li>
<li>将处理结果更新到 HTML页面中</li>

<h3 id="3-封装"><a href="#3-封装" class="headerlink" title="3.封装"></a>3.封装</h3><p>通过上面对<code>XMLHttpRequest</code>对象的了解，下面来封装一个简单的 ajax 请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装一个ajax请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="comment">//创建XMLHttpRequest对象</span></span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化参数的内容</span></span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    options.<span class="property">type</span> = (options.<span class="property">type</span> || <span class="string">&#x27;GET&#x27;</span>).<span class="title function_">toUpperCase</span>()</span><br><span class="line">    options.<span class="property">dataType</span> = options.<span class="property">dataType</span> || <span class="string">&#x27;json&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> params = options.<span class="property">data</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">type</span> === <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, options.<span class="property">url</span> + <span class="string">&#x27;?&#x27;</span> + params, <span class="literal">true</span>)</span><br><span class="line">        xhr.<span class="title function_">send</span>(<span class="literal">null</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.<span class="property">type</span> === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, options.<span class="property">url</span>, <span class="literal">true</span>)</span><br><span class="line">        xhr.<span class="title function_">send</span>(params)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收请求</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> status = xhr.<span class="property">status</span></span><br><span class="line">            <span class="keyword">if</span> (status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                options.<span class="property">success</span> &amp;&amp; options.<span class="title function_">success</span>(xhr.<span class="property">responseText</span>, xhr.<span class="property">responseXML</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                options.<span class="property">fail</span> &amp;&amp; options.<span class="title function_">fail</span>(status)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;https://xxxx&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">text, xml</span>) &#123;</span><br><span class="line">    <span class="comment">//请求成功后的回调函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(text)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">fail</span>: <span class="keyword">function</span> (<span class="params">status</span>) &#123;</span><br><span class="line">    <span class="comment">////请求失败后的回调函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(status)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="bind-call-apply-区别"><a href="#bind-call-apply-区别" class="headerlink" title="bind,call,apply 区别"></a>bind,call,apply 区别</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><p><code>call</code>、<code>apply</code>、<code>bind</code>作用是改变函数执行时的上下文，简而言之就是改变函数运行时的 this 指向</p>
<p>那么什么情况下需要改变 this 的指向呢？下面举个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;lucy&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;martin&#x27;</span>,</span><br><span class="line">  <span class="attr">say</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">say</span>() <span class="comment">// martin，this 指向 obj 对象</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">say</span>, <span class="number">0</span>) <span class="comment">// lucy，this 指向 window 对象</span></span><br></pre></td></tr></table></figure>
<p>从上面可以看到，正常情况 say 方法输出 martin</p>
<p>但是我们把 say 放在 setTimeout 方法中，在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，这时候 this 指向 window，所以输出 lucy</p>
<p>我们实际需要的是 this 指向 obj 对象，这时候就需要该改变 this 指向了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">say</span>.<span class="title function_">bind</span>(obj), <span class="number">0</span>) <span class="comment">//martin，this指向obj对象</span></span><br></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>下面再来看看<code>apply</code>、<code>call</code>、<code>bind</code>的使用</p>
<p><strong>apply</strong></p>
<p><code>apply</code>接受两个参数，第一个参数是<code>this</code>的指向，第二个参数是函数接受的参数，以数组的形式传入</p>
<p>改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">myname</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">apply</span>(obj, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// this会变成传入的obj，传入的参数必须是一个数组；</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>
<p>当第一个参数为<code>null</code>、<code>undefined</code>的时候，默认指向<code>window</code>(在浏览器中)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// this指向window</span></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">undefined</span>, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>
<p><strong>call</strong></p>
<p><code>call</code>方法的第一个参数也是<code>this</code>的指向，后面传入的是一个参数列表</p>
<p>跟 apply 一样，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">myname</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">call</span>(obj, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// this会变成传入的obj，传入的参数必须是一个数组；</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>
<p>同样的，当第一个参数为<code>null</code>、<code>undefined</code>的时候，默认指向<code>window</code>(在浏览器中)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.<span class="title function_">call</span>(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// this指向window</span></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">undefined</span>, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>
<p><strong>bind</strong></p>
<p>bind 方法和 call 很相似，第一参数也是<code>this</code>的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)</p>
<p>改变<code>this</code>指向后不会立即执行，而是返回一个永久改变<code>this</code>指向的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">myname</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindFn = fn.<span class="title function_">bind</span>(obj) <span class="comment">// this 也会变成传入的obj ，bind不是立即执行需要执行一次</span></span><br><span class="line"><span class="title function_">bindFn</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// this指向obj</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>
<p><strong>小结</strong></p>
<p>从上面可以看到，<code>apply</code>、<code>call</code>、<code>bind</code>三者的区别在于：</p>
<li>三者都可以改变函数的this对象指向</li>
<li>三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window</li>
<li>三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入</li>
<li>bind是返回绑定this之后的函数，apply、call 则是立即执行</li>

<h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h3><p>实现<code>bind</code>的步骤，我们可以分解成为三部分：</p>
<li>修改this指向</li>
<li>动态传递参数</li>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：只在bind中传递函数参数</span></span><br><span class="line">fn.<span class="title function_">bind</span>(obj, <span class="number">1</span>, <span class="number">2</span>)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：在bind中传递函数参数，也在返回函数中传递参数</span></span><br><span class="line">fn.<span class="title function_">bind</span>(obj, <span class="number">1</span>)(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<li>兼容new关键字</li>

<p>整体实现代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">    fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="keyword">new</span> <span class="title function_">fn</span>(...<span class="variable language_">arguments</span>) : context,</span><br><span class="line">      args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式的理解-应用场景"><a href="#正则表达式的理解-应用场景" class="headerlink" title="正则表达式的理解 应用场景"></a>正则表达式的理解 应用场景</h2><h3 id="1-是什么-5"><a href="#1-是什么-5" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>正则表达式是一种用来匹配字符串的强有力的武器</p>
<p>它的设计思想是用一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的</p>
<p>在 <code>JavaScript</code>中，正则表达式也是对象，构建正则表达式有两种方式：</p>
<ol>
<li>字面量创建，其由包含在斜杠之间的模式组成</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/\d+/g</span></span><br></pre></td></tr></table></figure>
<ol>
<li>调用 RegExp 对象的构造函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\d+&#x27;</span>, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rul = <span class="string">&#x27;\\d+&#x27;</span></span><br><span class="line"><span class="keyword">const</span> re1 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(rul, <span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用构建函数创建，第一个参数可以是一个变量，遇到特殊字符\需要使用\进行转义</p>
<h3 id="2-匹配规则"><a href="#2-匹配规则" class="headerlink" title="2.匹配规则"></a>2.匹配规则</h3><p>常见的匹配规则如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>规则</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>转义</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入的结束</td>
</tr>
<tr>
<td>*</td>
<td>匹配前一个表达式 0 次或多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面一个表达式 1 次或者多次。等价于 {1,}</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面一个表达式 0 次或者 1 次。等价于{0,1}</td>
</tr>
<tr>
<td>.</td>
<td>默认匹配除换行符之外的任何单个字符</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<h2 id="对事件循环的理解"><a href="#对事件循环的理解" class="headerlink" title="对事件循环的理解"></a>对事件循环的理解</h2><h3 id="1-是什么-6"><a href="#1-是什么-6" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>首先，<code>JavaScript</code>是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环</p>
<p>在<code>JavaScript</code>中，所有的任务都可以分为</p>
<li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</li>
<li>异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等</li>

<p>同步任务与异步任务的运行流程图如下：</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/事件循环1.png"/></div></div>
<p>从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环</p>
<h3 id="2-宏任务与微任务"><a href="#2-宏任务与微任务" class="headerlink" title="2.宏任务与微任务"></a>2.宏任务与微任务</h3><p>如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new Promise&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>如果按照上面流程图来分析代码，我们会得到下面的执行步骤：</p>
<li>console.log(1)，同步任务，主线程中执行</li>
<li>setTimeout() ，异步任务，放到 Event Table，0 毫秒后console.log(2)回调推入 Event Queue 中</li>
<li>new Promise ，同步任务，主线程直接执行</li>
<li>.then ，异步任务，放到 Event Table</li>
<li>console.log(3)，同步任务，主线程执行</li>

<p>所以按照分析，它的结果应该是 <code>1 =&gt; &#39;new Promise&#39; =&gt; 3 =&gt; 2 =&gt; &#39;then&#39;</code></p>
<p>但是实际结果是：<code>1=&gt;&#39;new Promise&#39;=&gt; 3 =&gt; &#39;then&#39; =&gt; 2</code></p>
<p>出现分歧的原因在于异步任务执行顺序，事件队列其实是一个<code>“先进先出”</code>的数据结构，排在前面的事件会优先被主线程读取</p>
<p>例子中 <code>setTimeout</code>回调事件是先进入队列中的，按理说应该先于 .then 中的执行，但是结果却偏偏<code>相反</code></p>
<p>原因在于异步任务还可以细分为<code>宏任务</code>与<code>微任务</code></p>
<p><strong>宏任务</strong><br>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合<br>常见的宏任务有：</p>
<li>script (可以理解为外层同步代码)</li>
<li>setTimeout/setInterval</li>
<li>UI rendering/UI事件</li>
<li>postMessage、MessageChannel</li>
<li>setImmediate、I/O（Node.js）</li>

<p><strong>微任务</strong><br>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p>
<p>常见的微任务有：</p>
<li>Promise.then</li>
<li>MutaionObserver</li>
<li>Object.observe（已废弃；Proxy 对象替代）</li>
<li>process.nextTick（Node.js）</li>

<p>这时候，事件循环，那个任务，微任务的关系如图所示:<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/事件循环2.png"/></div></div></p>
<p>按照这个流程，它的执行机制是：</p>
<li>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中</li>
<li>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</li>

<p>回到上面题目</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new Promise&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>流程如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遇到 console.log(1) ，直接打印 1</span></span><br><span class="line"><span class="comment">// 遇到定时器，属于新的宏任务，留着后面执行</span></span><br><span class="line"><span class="comment">// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;</span></span><br><span class="line"><span class="comment">// .then 属于微任务，放入微任务队列，后面再执行</span></span><br><span class="line"><span class="comment">// 遇到 console.log(3) 直接打印 3</span></span><br><span class="line"><span class="comment">// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;</span></span><br><span class="line"><span class="comment">// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2</span></span><br></pre></td></tr></table></figure>
<h3 id="async-与-await"><a href="#async-与-await" class="headerlink" title="async 与 await"></a>async 与 await</h3><p><code>async</code> 是异步的意思，await 则可以理解为 <code>async wait</code>。所以可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await</code>是用来等待异步方法执行</p>
<p><strong>async</strong></p>
<p>async 函数返回一个 promise 对象，下面两种方法是等效的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;TEST&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// asyncF is equivalent to f!</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncF</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;TEST&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>await</strong></p>
<p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code>对象，返回该对象的结果。如果不是 <code>Promise</code>对象，就直接返回对应的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="comment">// return 123</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">fn2</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>) <span class="comment">// 阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async</code>外面的同步代码，同步代码执行完，再回到 async 函数中，再执行之前阻塞的代码</p>
<p>所以上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p>
<h3 id="4-流程分析"><a href="#4-流程分析" class="headerlink" title="4.流程分析"></a>4.流程分析</h3><p>通过对上面的了解，我们对 JavaScript 对各种场景的执行顺序有了大致的了解</p>
<p>这里直接上代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>分析过程:</p>
<ol>
<li>执行整段代码，遇到 <code>console.log(&#39;script start&#39;)</code> 直接打印结果，输出 <code>script start</code></li>
<li>遇到定时器了，它是宏任务，先放着不执行</li>
<li>遇到 <code>async1()</code>，执行 <code>async1</code> 函数，先打印 <code>async1 start</code>，下面遇到 await 怎么办？先执行<code>async2</code>，打印 <code>async2</code>，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码</li>
<li>跳到 <code>new Promise</code> 这里，直接执行，打印 <code>promise1</code>，下面遇到 <code>.then()</code>，它是<code>微任务</code>，放到微任务列表等待执行</li>
<li>最后一行直接打印 <code>script end</code>，现在同步代码执行完了，开始执行微任务，即 <code>await</code> 下面的代码，打印 <code>async1 end</code></li>
<li>继续执行下一个微任务，即执行 <code>then</code>的回调，打印 <code>promise2</code></li>
<li>上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 <code>settimeout</code></li>
</ol>
<p>所以最后的结果是：<code>script start</code>、<code>async1 start</code>、<code>async2</code>、<code>promise1</code>、<code>script end</code>、<code>async1 end</code>、<code>promise2</code>、<code>settimeout</code></p>
<h2 id="JavaScript-内存泄漏"><a href="#JavaScript-内存泄漏" class="headerlink" title="JavaScript 内存泄漏"></a>JavaScript 内存泄漏</h2><h3 id="1-是什么-7"><a href="#1-是什么-7" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存</p>
<p>并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费</p>
<p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存</p>
<p>对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃</p>
<h3 id="2-垃圾回收机制"><a href="#2-垃圾回收机制" class="headerlink" title="2.垃圾回收机制"></a>2.垃圾回收机制</h3><p>Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存</p>
<p>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存</p>
<p>通常情况下有两种实现方式：</p>
<li>标记清除</li>
<li>引用计数</li>

<p><strong>标记清除</strong></p>
<p><code>JavaScript</code>最常用的垃圾收回机制</p>
<p>当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“</p>
<p>垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉</p>
<p>在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了</p>
<p>随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存</p>
<p>举个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">0</span>,</span><br><span class="line">  n = <span class="number">19</span> <span class="comment">// 把 m,n,add() 标记为进入环境。</span></span><br><span class="line"><span class="title function_">add</span>(m, n) <span class="comment">// 把 a, b, c标记为进入环境。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">// a,b,c标记为离开环境，等待垃圾回收。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  a++</span><br><span class="line">  <span class="keyword">var</span> c = a + b</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>引用计数</strong><br>语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放</p>
<p>如果一个值不再需要了，引用数却不为 0，垃圾回收机制无法释放这块内存，从而导致内存泄漏</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量 arr 是仅有的对这个值的引用，因此引用次数为 1。尽管后面的代码没有用到 arr，它还是会持续占用内存</p>
<p>如果需要这块内存被垃圾回收机制释放，只需要设置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>通过设置 arr 为 null，就解除了对数组[1,2,3,4]的引用，引用次数变为 0，就被垃圾回收了</p>
<p><strong>小结</strong><br>有了垃圾回收机制，不代表不用关注内存泄露。那些很占空间的值，一旦不再用到，需要检查是否还存在对它们的引用。如果是的话，就必须手动解除引用</p>
<h2 id="JavaScript-本地存储方式-区别及应用场景"><a href="#JavaScript-本地存储方式-区别及应用场景" class="headerlink" title="JavaScript 本地存储方式 区别及应用场景"></a>JavaScript 本地存储方式 区别及应用场景</h2><h3 id="1-方式"><a href="#1-方式" class="headerlink" title="1.方式"></a>1.方式</h3><p><code>javaScript</code>本地缓存的方法我们主要讲述以下四种：</p>
<li>cookie</li>
<li>sessionStorage</li>
<li>localStorage</li>
<li>indexedDB</li>

<p><strong>cookie</strong></p>
<p><code>Cookie</code>，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 HTTP 无状态导致的问题</p>
<p>作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 <code>cookie``有效期</code>、<code>安全性</code>、<code>使用范围</code>的可选属性组成</p>
<p>但是<code>cookie</code>在每次请求中都会被发送，如果不使用 <code>HTTPS</code>并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 <code>cookie</code>保持登录态的网站上，如果 <code>cookie</code>被窃取，他人很容易利用你的 <code>cookie</code>来假扮成你登录网站</p>
<p>关于 cookie 常用的属性如下：<br>Expires 用于设置 Cookie 的过期时间</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Expires</span>=<span class="title class_">Wed</span>, <span class="number">21</span> <span class="title class_">Oct</span> <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> <span class="variable constant_">GMT</span></span><br></pre></td></tr></table></figure>
<p>Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比 Expires 高）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Max</span>-<span class="title class_">Age</span>=<span class="number">604800</span></span><br></pre></td></tr></table></figure>
<p><code>Domain</code>指定了 <code>Cookie</code>可以送达的主机名<br><code>Path</code>指定了一个 <code>URL</code>路径，这个路径必须出现在要请求的资源的路径中才可以发送 <code>Cookie</code> 首部</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Path</span>=<span class="regexp">/docs   # /</span>docs/<span class="title class_">Web</span>/ 下的资源会带 <span class="title class_">Cookie</span> 首部</span><br></pre></td></tr></table></figure>
<p>标记为 <code>Secure</code>的 <code>Cookie</code>只应通过被 HTTPS 协议加密过的请求发送给服务端</p>
<p>通过上述，我们可以看到<code>cookie</code>又开始的作用并不是为了缓存而设计出来，只是借用了<code>cookie</code>的特性实现缓存</p>
<p>关于<code>cookie</code>的使用如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;名字=值&#x27;</span></span><br></pre></td></tr></table></figure>
<p>关于 <code>cookie</code> 的修改，首先要确定 <code>domain</code>和 <code>path</code> 属性都是相同的才可以，其中有一个不同得时候都会创建出一个新的 <code>cookie</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>:name=aa; domain=aa.<span class="property">net</span>; path=/  # 服务端设置</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> =name=bb; domain=aa.<span class="property">net</span>; path=/  # 客户端设置</span><br></pre></td></tr></table></figure>
<p>最后<code>cookie</code>的删除，最常用的方法就是给 cookie 设置一个过期的事件，这样 cookie 过期后会被浏览器删除</p>
<p><strong>localStorage</strong><br>HTML5 新方法，IE8 及以上浏览器都兼容</p>
<p><strong>特点</strong></p>
<li>生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</li>
<li>存储的信息在同一域中是共享的</li>
<li>当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。</li>
<li>大小：5M（跟浏览器厂商有关系）</li>
<li>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li>
<li>受同源策略的限制</li>

<p>下面再看看关于<code>localStorage</code>的使用</p>
<p>设置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;cfangxu&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>获取</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;username&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>获取键名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">key</span>(<span class="number">0</span>) <span class="comment">//获取第一个键名</span></span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;username&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>一次性清除所有存储</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure>
<p><code>localStorage</code> 也不是完美的，它有两个缺点：</p>
<li>无法像Cookie一样设置过期时间</li>
<li>只能存入字符串，无法直接存对象</li>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;value&#x27;</span> &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>)) <span class="comment">// &#x27;[object, Object]&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>sessionStorage</strong><br>sessionStorage 和 localStorage 使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，sessionStorage 将会删除数据</p>
<p><strong>扩展的前端存储方式</strong><br>indexedDB 是一种低级 API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该 API 使用索引来实现对该数据的高性能搜索</p>
<p>虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB 提供了一个解决方案</p>
<p><strong>优点:</strong></p>
<li>储存量理论上没有上限</li>
<li>所有操作都是异步的，相比 LocalStorage 同步操作性能更高，尤其是数据量较大时</li>
<li>原生支持储存JS的对象</li>
<li>是个正经的数据库，意味着数据库能干的事它都能干</li>

<p><strong>缺点:</strong></p>
<li>操作非常繁琐</li>
<li>本身有一定门槛</li>

<h3 id="2-区别"><a href="#2-区别" class="headerlink" title="2.区别"></a>2.区别</h3><p>关于<code>cookie</code>、<code>sessionStorage</code>、<code>localStorage</code>三者的区别主要如下：</p>
<li>存储大小：cookie数据大小不能超过4k，sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li>
<li>有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage数据在当前浏览器窗口关闭后自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>
<li>数据与服务器之间的交互方式，cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端； sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存</li>

<h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h3><p>在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：</p>
<li>标记用户与跟踪用户行为的情况，推荐使用cookie</li>
<li>适合长期保存在本地的数据（令牌），推荐使用localStorage</li>
<li>敏感账号一次性登录，推荐使用sessionStorage</li>
<li>存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB</li>

<h2 id="JavaScript-数字精度丢失的问题-如何解决"><a href="#JavaScript-数字精度丢失的问题-如何解决" class="headerlink" title="JavaScript 数字精度丢失的问题,如何解决"></a>JavaScript 数字精度丢失的问题,如何解决</h2><h3 id="1-场景复现"><a href="#1-场景复现" class="headerlink" title="1.场景复现"></a>1.场景复现</h3><p>一个经典的面试题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>为什么是<code>false</code>呢?</p>
<p>先看下面这个比喻</p>
<p>比如一个数 1÷3=0.33333333……</p>
<p>3 会一直无限循环，数学可以表示，但是计算机要存储，方便下次取出来再使用，但 0.333333…… 这个数无限循环，再大的内存它也存不下，所以不能存储一个相对于数学来说的值，只能存储一个近似值，当计算机存储后再取出时就会出现精度丢失问题</p>
<h3 id="2-浮点数"><a href="#2-浮点数" class="headerlink" title="2.浮点数"></a>2.浮点数</h3><p>“浮点数”是一种表示数字的标准，整数也可以用浮点数的格式来存储</p>
<p>我们也可以理解成，浮点数就是小数</p>
<p>在<code>JavaScript</code>中，现在主流的数值类型是<code>Number</code>，而<code>Number</code>采用的是 IEEE754 规范中 64 位双精度浮点数编码</p>
<p>这样的存储结构优点是可以归一化处理整数和小数，节省存储空间</p>
<p>对于一个整数，可以很轻易转化成十进制或者二进制。但是对于一个浮点数来说，因为小数点的存在，小数点的位置不是固定的。解决思路就是使用科学计数法，这样小数点位置就固定了</p>
<h3 id="3-问题分析"><a href="#3-问题分析" class="headerlink" title="3.问题分析"></a>3.问题分析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>通过上面的学习，我们知道，在 javascript 语言中，0.1 和 0.2 都转化成二进制后再进行运算</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.1 和 0.2 都转化成二进制后再进行运算</span></span><br><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011010</span> +</span><br><span class="line"><span class="number">0.0011001100110011001100110011001100110011001100110011010</span> =</span><br><span class="line"><span class="number">0.0100110011001100110011001100110011001100110011001100111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转成十进制正好是 0.30000000000000004</span></span><br></pre></td></tr></table></figure>
<p>所以输出 false</p>
<p>再来一个问题，那么为什么<code>x=0.1</code>得到<code>0.1</code>？</p>
<p>主要是存储二进制时小数点的偏移量最大为 52 位，最多可以表达的位数是<code>2^53=9007199254740992</code>，对应科学计数尾数是 <code>9.007199254740992</code>，这也是 JS 最多能表示的精度</p>
<p>它的长度是 16，所以可以使用 <code>toPrecision(16)</code>来做精度运算，超过的精度会自动做凑整处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="number">0.10000000000000000555</span>).<span class="title function_">toPrecision</span>(<span class="number">16</span>)</span><br><span class="line"><span class="comment">// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1</span></span><br></pre></td></tr></table></figure>
<p>但看到的 0.1 实际上并不是 0.1。不信你可用更高的精度试试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span>.<span class="title function_">toPrecision</span>(<span class="number">21</span>) = <span class="number">0.100000000000000005551</span></span><br></pre></td></tr></table></figure>
<p><strong>小结</strong><br>计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，然后计算机以自己的规则{符号位+(指数位+指数偏移量的二进制)+小数部分}存储二进制的科学记数法</p>
<p>因为存储时有位数限制（64 位），并且某些十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0 舍 1 入)，当再转换为十进制时就造成了计算误差</p>
<h3 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a>4.解决方案</h3><p>理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果</p>
<p>当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">1.4000000000000001</span>).<span class="title function_">toPrecision</span>(<span class="number">12</span>)) === <span class="number">1.4</span> <span class="comment">// True</span></span><br></pre></td></tr></table></figure>
<p>封装成方法就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strip</span>(<span class="params">num, precision = <span class="number">12</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="built_in">parseFloat</span>(num.<span class="title function_">toPrecision</span>(precision))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 精确加法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> num1Digits = (num1.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span>).<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> num2Digits = (num2.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span>).<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> baseNum = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>, <span class="title class_">Math</span>.<span class="title function_">max</span>(num1Digits, num2Digits))</span><br><span class="line">  <span class="keyword">return</span> (num1 * baseNum + num2 * baseNum) / baseNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还可以使用第三方库，如<code>Math.js</code>、<code>BigDecimal.js</code></p>
<h2 id="什么是防抖和节流"><a href="#什么是防抖和节流" class="headerlink" title="什么是防抖和节流"></a>什么是防抖和节流</h2><h3 id="1-是什么-8"><a href="#1-是什么-8" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>本质上是优化高频率执行代码的一种手段</p>
<p>如：浏览器的<code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p>
<p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 <strong>防抖（debounce）</strong> 和 <strong>节流（throttle）</strong> 的方式来减少调用频率</p>
<p><strong>定义</strong></p>
<li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</li>
<li>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</li>

<p>一个经典的比喻:</p>
<p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应</p>
<p>假设电梯有两种运行策略 debounce 和 throttle，超时设定为 15 秒，不考虑容量限制</p>
<p>电梯第一个人进来后，15 秒后准时运送一次，这是节流</p>
<p>电梯第一个人进来后，等待 15 秒。如果过程中又有人进来，15 秒等待重新计时，直到 15 秒后开始运送，这是防抖</p>
<h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p><strong>节流</strong></p>
<p>完成节流可以使用时间戳与定时器的写法</p>
<p>使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled1</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> oldtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> newtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">if</span> (newtime - oldtime &gt;= delay) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="literal">null</span>, args)</span><br><span class="line">      oldtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用定时器写法，<code>delay</code>毫秒后第一次执行，第二次事件停止触发后依然会再一次执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled2</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> starttime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="keyword">let</span> remaining = delay - (curTime - starttime) <span class="comment">// 从上一次到现在，还剩下多少多余时间</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">      starttime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(fn, remaining)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>防抖</strong></p>
<p>简单版本的实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span> <span class="comment">// 保存this指向</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span> <span class="comment">// 拿到event对象</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait, immediate</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout) <span class="comment">// timeout 不为null</span></span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">let</span> callNow = !timeout <span class="comment">// 第一次会立即执行，以后只有事件执行后才会再次触发</span></span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">      <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">        func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-区别-1"><a href="#3-区别-1" class="headerlink" title="3.区别"></a>3.区别</h3><p>相同点:</p>
<li>都可以通过使用 setTimeout 实现</li>
<li>目的都是，降低回调执行频率。节省计算资源</li>

<p>不同点:</p>
<li>函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能</li>
<li>函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次</li>

<p>例如，都设置时间频率为 500ms，在 2 秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在 2s 后，只会执行一次</p>
<p>如下图所示<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/防抖节流区别1.png"/></div></div></p>
<h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4.应用场景"></a>4.应用场景</h3><p>防抖在连续的事件，只需触发一次回调的场景有：</p>
<li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li>
<li>手机号、邮箱验证输入检测</li>
<li>窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li>

<p>节流在间隔一段时间执行一次回调的场景有：</p>
<li>滚动加载，加载更多或滚到底部监听</li>
<li>搜索框，搜索联想功能</li>

<h2 id="如何判断一个元素是否在可视区域内"><a href="#如何判断一个元素是否在可视区域内" class="headerlink" title="如何判断一个元素是否在可视区域内"></a>如何判断一个元素是否在可视区域内</h2><h3 id="1-用途"><a href="#1-用途" class="headerlink" title="1.用途"></a>1.用途</h3><p>可视区域即我们浏览网页的设备肉眼可见的区域，如下图<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/可视区1.png"/></div></div></p>
<p>在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如</p>
<li>图片的懒加载</li>
<li>列表的无限滚动</li>
<li>计算广告元素的曝光情况</li>
<li>可点击链接的预加载</li>

<h3 id="2-实现方式-1"><a href="#2-实现方式-1" class="headerlink" title="2.实现方式"></a>2.实现方式</h3><p>判断一个元素是否在可视区域，我们常用的有三种办法：</p>
<li>offsetTop、scrollTop</li>
<li>getBoundingClientRect</li>
<li>Intersection Observer</li>

<p><strong>offsetTop、scrollTop</strong></p>
<p><code>offsetTop</code>，元素的上外边框至包含元素的上内边框之间的像素距离，其他 offset 属性如下图所示：<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/offset偏移量1.png"/></div></div></p>
<p>下面再来了解下<code>clientWidth</code>、<code>clientHeight</code>：</p>
<li>clientWidth：元素内容区宽度加上左右内边距宽度，即clientWidth = content + padding</li>
<li>clientHeight：元素内容区高度加上上下内边距高度，即clientHeight = content + padding</li>

<p>这里可以看到 client 元素都不包括外边距</p>
<p>最后，关于 scroll 系列的属性如下：</p>
<li>scrollWidth 和 scrollHeight 主要用于确定元素内容的实际大小</li>
<li>scrollLeft 和 scrollTop 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置</li>
<li>垂直滚动 scrollTop > 0 ,水平滚动 scrollLeft > 0</li>
<li>将元素的 scrollLeft 和 scrollTop 设置为 0，可以重置元素的滚动位置</li>

<p><strong>注意</strong></p>
<li>上述属性都是只读的，每次访问都要重新开始</li>

<p>下面再看看如何实现判断:</p>
<p>公式如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="property">offsetTop</span> - <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> &lt;= viewPortHeight</span><br></pre></td></tr></table></figure>
<p>代码实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPortOfOne</span>(<span class="params">el</span>) &#123;</span><br><span class="line">  <span class="comment">// viewPortHeight 兼容所有浏览器写法</span></span><br><span class="line">  <span class="keyword">const</span> viewPortHeight =</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">innerHeight</span> ||</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> ||</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span></span><br><span class="line">  <span class="keyword">const</span> offsetTop = el.<span class="property">offsetTop</span></span><br><span class="line">  <span class="keyword">const</span> scrollTop = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span></span><br><span class="line">  <span class="keyword">const</span> top = offsetTop - scrollTop</span><br><span class="line">  <span class="keyword">return</span> top &lt;= viewPortHeight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getBoundingClientRect</strong></p>
<p>返回值是一个 DOMRect 对象，拥有 left, top, right, bottom, x, y, width, 和 height 属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.target&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> clientRect = target.<span class="title function_">getBoundingClientRect</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(clientRect)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   bottom: 556.21875,</span></span><br><span class="line"><span class="comment">//   height: 393.59375,</span></span><br><span class="line"><span class="comment">//   left: 333,</span></span><br><span class="line"><span class="comment">//   right: 1017,</span></span><br><span class="line"><span class="comment">//   top: 162.625,</span></span><br><span class="line"><span class="comment">//   width: 684</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>属性对应的关系图如下所示 ：<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/getBoundingClientRect.png"/></div></div></p>
<p>当页面发生滚动的时候，<code>top</code>与<code>left</code>属性值都会随之改变</p>
<p>如果一个元素在视窗之内的话，那么它一定满足下面四个条件：</p>
<li>top 大于等于 0</li>
<li>left 大于等于 0</li>
<li>bottom 小于等于视窗高度</li>
<li>right 小于等于视窗宽度</li>

<p>实现代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPort</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> viewWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line">  <span class="keyword">const</span> viewHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">  <span class="keyword">const</span> &#123; top, right, bottom, left &#125; = element.<span class="title function_">getBoundingClientRect</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> top &gt;= <span class="number">0</span> &amp;&amp; left &gt;= <span class="number">0</span> &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Intersection Observer</strong></p>
<p><code>Intersection Observer</code> 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比 getBoundingClientRect 会好很多</p>
<p>使用步骤主要分为两步：创建观察者和传入被观察者</p>
<p><strong>创建观察者</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="comment">// 表示重叠面积占被观察者的比例，从 0 - 1 取值，</span></span><br><span class="line">  <span class="comment">// 1 表示完全被包含</span></span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">1.0</span>,</span><br><span class="line">  <span class="attr">root</span>:<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#scrollArea&#x27;</span>) <span class="comment">// 必须是目标元素的父级元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params">entries, observer</span>) =&gt; &#123; ....&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback, options);</span><br></pre></td></tr></table></figure>
<p>通过<code>new IntersectionObserver</code>创建了观察者 <code>observer</code>，传入的参数 <code>callback</code> 在重叠比例超过 <code>threshold</code> 时会被执行`</p>
<p>关于<code>callback</code>回调函数常用属性如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上段代码中被省略的 callback</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="keyword">function</span> (<span class="params">entries, observer</span>) &#123;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">    entry.<span class="property">time</span> <span class="comment">// 触发的时间</span></span><br><span class="line">    entry.<span class="property">rootBounds</span> <span class="comment">// 根元素的位置矩形，这种情况下为视窗位置</span></span><br><span class="line">    entry.<span class="property">boundingClientRect</span> <span class="comment">// 被观察者的位置举行</span></span><br><span class="line">    entry.<span class="property">intersectionRect</span> <span class="comment">// 重叠区域的位置矩形</span></span><br><span class="line">    entry.<span class="property">intersectionRatio</span> <span class="comment">// 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）</span></span><br><span class="line">    entry.<span class="property">target</span> <span class="comment">// 被观察者</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>传入被观察者</strong></p>
<p>通过 <code>observer.observe(target)</code> 这一行代码即可简单的注册被观察者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.target&#x27;</span>)</span><br><span class="line">observer.<span class="title function_">observe</span>(target)</span><br></pre></td></tr></table></figure>
<h3 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3.案例分析"></a>3.案例分析</h3><p>实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色</p>
<p><code>Html</code>结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>css</code>样式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.target</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>往<code>container</code>插入 1000 个元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $container = $(<span class="string">&#x27;.container&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入 100000 个 &lt;div class=&quot;target&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createTargets</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> htmlString = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">100000</span>)</span><br><span class="line">    .<span class="title function_">fill</span>(<span class="string">&#x27;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&#x27;</span>)</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  $container.<span class="title function_">html</span>(htmlString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，首先使用<code>getBoundingClientRect</code>方法进行判断元素是否在可视区域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPort</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> viewWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line">  <span class="keyword">const</span> viewHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">  <span class="keyword">const</span> &#123; top, right, bottom, left &#125; = element.<span class="title function_">getBoundingClientRect</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> top &gt;= <span class="number">0</span> &amp;&amp; left &gt;= <span class="number">0</span> &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后开始监听<code>scroll</code>事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为<code>yellow</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">on</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scroll !&#x27;</span>)</span><br><span class="line">  $targets.<span class="title function_">each</span>(<span class="function">(<span class="params">index, element</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isInViewPort</span>(element)) &#123;</span><br><span class="line">      $(element).<span class="title function_">css</span>(<span class="string">&#x27;background-color&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了<code>scroll</code>事件，<code>scroll</code>事件伴随了大量的计算，会造成资源方面的浪费</p>
<p>下面通过<code>Intersection Observer</code>的形式同样实现相同的功能</p>
<p>首先创建一个观察者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(getYellow, &#123; <span class="attr">threshold</span>: <span class="number">1.0</span> &#125;)</span><br></pre></td></tr></table></figure>
<p><code>getYellow</code>回调函数实现对背景颜色改变，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getYellow</span>(<span class="params">entries, observer</span>) &#123;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">    $(entry.<span class="property">target</span>).<span class="title function_">css</span>(<span class="string">&#x27;background-color&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后传入观察者，即<code>.target</code>元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$targets.<span class="title function_">each</span>(<span class="function">(<span class="params">index, element</span>) =&gt;</span> &#123;</span><br><span class="line">  observer.<span class="title function_">observe</span>(element)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="string">``</span></span><br><span class="line">可以看到功能同样完成，并且页面不会出现卡顿的情况</span><br></pre></td></tr></table></figure>
<h2 id="大文件如何做断点续传"><a href="#大文件如何做断点续传" class="headerlink" title="大文件如何做断点续传"></a>大文件如何做断点续传</h2><h3 id="1-是什么-9"><a href="#1-是什么-9" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂</p>
<p>文件上传简单，文件变大就复杂</p>
<p>上传大文件时，以下几个变量会影响我们的用户体验</p>
<li>服务器处理数据的能力</li>
<li>请求超时</li>
<li>网络波动</li>

<p>上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等</p>
<p>为了解决上述问题，我们需要对大文件上传单独处理</p>
<p>这里涉及到分片上传及断点续传两个概念</p>
<p><strong>分片上传</strong><br>分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传<br>如下图<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/分片上传.png"/></div></div></p>
<p>上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件</p>
<p>大致流程如下：</p>
<ol>
<li>将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；</li>
<li>初始化一个分片上传任务，返回本次分片上传唯一标识；</li>
<li>按照一定的策略（串行或并行）发送各个分片数据块；</li>
<li>发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件</li>
</ol>
<p><strong>断点续传</strong></p>
<p>断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分</p>
<p>每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度</p>
<p>一般实现方式有两种</p>
<li>服务器端返回，告知从哪开始</li>
<li>浏览器端自行处理</li>

<p>上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可</p>
<p>如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可</p>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h3><li>大文件加速上传：当文件大小超过预期大小时，使用分片上传可实现并行上传多个 Part， 以加快上传速度</li>
<li>网络环境较差：建议使用分片上传。当出现上传失败的时候，仅需重传失败的Part</li>
<li>流式上传：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在视频监控等行业应用中比较常见</li>

<h2 id="如何实现上拉加载，下拉刷新"><a href="#如何实现上拉加载，下拉刷新" class="headerlink" title="如何实现上拉加载，下拉刷新"></a>如何实现上拉加载，下拉刷新</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>下拉刷新和上拉加载这两种交互方式通常出现在移动端中</p>
<p>本质上等同于 PC 网页中的分页，只是交互形式不同</p>
<p>开源社区也有很多优秀的解决方案，如 iscroll、better-scroll、pulltorefresh.js 库等等</p>
<p>这些第三方库使用起来非常便捷</p>
<p>我们通过原生的方式实现一次上拉加载，下拉刷新，有助于对第三方库有更好的理解与使用</p>
<h3 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2.实现原理"></a>2.实现原理</h3><p>上拉加载及下拉刷新都依赖于用户交互</p>
<p>最重要的是要理解在什么场景，什么时机下触发交互动作</p>
<p><strong>上拉加载</strong><br>首先可以看一张图<br><div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/上拉加载1.png"/></div></div></p>
<p>上拉加载的本质是页面触底，或者快要触底时的动作</p>
<p>判断页面触底我们需要先了解一下下面几个属性</p>
<li>scrollTop：滚动视窗的高度距离window顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值</li>
<li>clientHeight:它是一个定值，表示屏幕可视区域的高度；</li>
<li>scrollHeight：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示body所有元素的总长度(包括body元素自身的padding)</li>

<p>综上我们得出一个触底公式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrollTop + clientHeight &gt;= scrollHeight</span><br></pre></td></tr></table></figure>
<p>简单实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> clientHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> <span class="comment">//浏览器高度</span></span><br><span class="line"><span class="keyword">let</span> scrollHeight = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span></span><br><span class="line"><span class="keyword">let</span> scrollTop = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> distance = <span class="number">50</span> <span class="comment">//距离视窗还用50的时候，开始触发；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (scrollTop + clientHeight &gt;= scrollHeight - distance) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始加载数据&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>下拉刷新</strong><br>下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作</p>
<p>关于下拉刷新的原生实现，主要分成三步：</p>
<li>监听原生touchstart事件，记录其初始位置的值，e.touches[0].pageY；</li>
<li>监听原生touchmove事件，记录并计算当前滑动的位置值与初始位置值的差值，大于0表示向下拉动，并借助CSS3的translateY属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li>
<li>监听原生touchend事件，若此时元素滑动达到最大值，则触发callback，同时将translateY重设为0，元素回到初始位置</li>

<p>举个例子:<br><code>html</code> 结构如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;main&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;refreshText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;refreshContainer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>444<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>555<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    ...</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;/main&gt;</span><br></pre></td></tr></table></figure>
<p>监听<code>touchstart</code>事件，记录初始的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;refreshContainer&#x27;</span>),</span><br><span class="line">  _refreshText = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.refreshText&#x27;</span>),</span><br><span class="line">  _startPos = <span class="number">0</span>, <span class="comment">// 初始的值</span></span><br><span class="line">  _transitionHeight = <span class="number">0</span> <span class="comment">// 移动的距离</span></span><br><span class="line"></span><br><span class="line">_element.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;touchstart&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    _startPos = e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">pageY</span> <span class="comment">// 记录初始位置</span></span><br><span class="line">    _element.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;relative&#x27;</span></span><br><span class="line">    _element.<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;transform 0s&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>监听<code>touchmove</code>移动事件，记录滑动差值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_element.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;touchmove&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// e.touches[0].pageY 当前位置</span></span><br><span class="line">    _transitionHeight = e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">pageY</span> - _startPos <span class="comment">// 记录差值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_transitionHeight &gt; <span class="number">0</span> &amp;&amp; _transitionHeight &lt; <span class="number">60</span>) &#123;</span><br><span class="line">      _refreshText.<span class="property">innerText</span> = <span class="string">&#x27;下拉刷新&#x27;</span></span><br><span class="line">      _element.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">&#x27;translateY(&#x27;</span> + _transitionHeight + <span class="string">&#x27;px)&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (_transitionHeight &gt; <span class="number">55</span>) &#123;</span><br><span class="line">        _refreshText.<span class="property">innerText</span> = <span class="string">&#x27;释放更新&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>最后，就是监听<code>touchend</code>离开的事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_element.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;touchend&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    _element.<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;transform 0.5s ease 1s&#x27;</span></span><br><span class="line">    _element.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">&#x27;translateY(0px)&#x27;</span></span><br><span class="line">    _refreshText.<span class="property">innerText</span> = <span class="string">&#x27;更新中...&#x27;</span></span><br><span class="line">    <span class="comment">// todo...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，在下拉到松手的过程中，经历了三个阶段：</p>
<li>当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作</li>
<li>下拉到一定值时，显示松手释放后的操作提示</li>
<li>下拉到达设定最大值松手时，执行回调，提示正在进行更新操作</li>

<h3 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h3><p>在实际开发中，我们更多的是使用第三方库，下面以<code>better-scroll</code>进行举例：</p>
<p>HTML 结构</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;position-wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;refresh&quot;</span>&gt;</span>下拉刷新<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;position-list&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--列表内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;more&quot;</span>&gt;</span>查看更多<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实例化上拉下拉插件，通过<code>use</code>来注册插件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">BScroll</span> <span class="keyword">from</span> <span class="string">&#x27;@better-scroll/core&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PullDown</span> <span class="keyword">from</span> <span class="string">&#x27;@better-scroll/pull-down&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PullUp</span> <span class="keyword">from</span> <span class="string">&#x27;@better-scroll/pull-up&#x27;</span></span><br><span class="line"><span class="title class_">BScroll</span>.<span class="title function_">use</span>(<span class="title class_">PullDown</span>)</span><br><span class="line"><span class="title class_">BScroll</span>.<span class="title function_">use</span>(<span class="title class_">PullUp</span>)</span><br></pre></td></tr></table></figure>
<p>实例化<code>BetterScroll</code>，并传入相关的参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pageNo = <span class="number">1</span>,pageSize = <span class="number">10</span>,dataList = [],isMore = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> scroll= <span class="keyword">new</span> <span class="title class_">BScroll</span>(<span class="string">&quot;#position-wrapper&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">scrollY</span>:<span class="literal">true</span>,<span class="comment">//垂直方向滚动</span></span><br><span class="line">    <span class="attr">click</span>:<span class="literal">true</span>,<span class="comment">//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true</span></span><br><span class="line">    <span class="attr">pullUpLoad</span>:<span class="literal">true</span>,<span class="comment">//上拉加载更多</span></span><br><span class="line">    <span class="attr">pullDownRefresh</span>:&#123;</span><br><span class="line">        <span class="attr">threshold</span>:<span class="number">50</span>,<span class="comment">//触发pullingDown事件的位置</span></span><br><span class="line">        <span class="attr">stop</span>:<span class="number">0</span><span class="comment">//下拉回弹后停留的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//监听下拉刷新</span></span><br><span class="line">scroll.<span class="title function_">on</span>(<span class="string">&quot;pullingDown&quot;</span>,pullingDownHandler);</span><br><span class="line"><span class="comment">//监测实时滚动</span></span><br><span class="line">scroll.<span class="title function_">on</span>(<span class="string">&quot;scroll&quot;</span>,scrollHandler);</span><br><span class="line"><span class="comment">//上拉加载更多</span></span><br><span class="line">scroll.<span class="title function_">on</span>(<span class="string">&quot;pullingUp&quot;</span>,pullingUpHandler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">pullingDownHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">    dataList=[];</span><br><span class="line">    pageNo=<span class="number">1</span>;</span><br><span class="line">    isMore=<span class="literal">true</span>;</span><br><span class="line">    $(<span class="string">&quot;.more&quot;</span>).<span class="title function_">text</span>(<span class="string">&quot;查看更多&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">getlist</span>();<span class="comment">//请求数据</span></span><br><span class="line">    scroll.<span class="title function_">finishPullDown</span>();<span class="comment">//每次下拉结束后，需要执行这个操作</span></span><br><span class="line">    scroll.<span class="title function_">refresh</span>();<span class="comment">//当滚动区域的dom结构有变化时，需要执行这个操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">pullingUpHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isMore)&#123;</span><br><span class="line">        $(<span class="string">&quot;.more&quot;</span>).<span class="title function_">text</span>(<span class="string">&quot;没有更多数据了&quot;</span>);</span><br><span class="line">        scroll.<span class="title function_">finishPullUp</span>();<span class="comment">//每次上拉结束后，需要执行这个操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pageNo++;</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getlist</span>();<span class="comment">//请求数据</span></span><br><span class="line">    scroll.<span class="title function_">finishPullUp</span>();<span class="comment">//每次上拉结束后，需要执行这个操作</span></span><br><span class="line">    scroll.<span class="title function_">refresh</span>();<span class="comment">//当滚动区域的dom结构有变化时，需要执行这个操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scrollHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">y</span>&gt;<span class="number">50</span>) $(<span class="string">&#x27;.refresh&#x27;</span>).<span class="title function_">text</span>(<span class="string">&quot;松手开始加载&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> $(<span class="string">&#x27;.refresh&#x27;</span>).<span class="title function_">text</span>(<span class="string">&quot;下拉刷新&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getlist</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//返回的数据</span></span><br><span class="line">    <span class="keyword">let</span> result=....;</span><br><span class="line">    dataList=dataList.<span class="title function_">concat</span>(result);</span><br><span class="line">    <span class="comment">//判断是否已加载完</span></span><br><span class="line">    <span class="keyword">if</span>(result.<span class="property">length</span>&lt;pageSize) isMore=<span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//将dataList渲染到html内容中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点:<br>使用<code>better-scroll</code>实现下拉刷新、上拉加载时要注意以下几点：</p>
<li>wrapper里必须只有一个子元素</li>
<li>子元素的高度要比wrapper要高</li>
<li>使用的时候，要确定DOM元素是否已经生成，必须要等到DOM渲染完成后，再new BScroll()</li>
<li>滚动区域的DOM元素结构有变化后，需要执行刷新 refresh()</li>
<li>上拉或者下拉，结束后，需要执行finishPullUp()或者finishPullDown()，否则将不会执行下次操作</li>
<li>better-scroll，默认会阻止浏览器的原生click事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置click:true</li>

<h2 id="什么是单点登录"><a href="#什么是单点登录" class="headerlink" title="什么是单点登录"></a>什么是单点登录</h2><h3 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1.是什么？"></a>1.是什么？</h3><p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一</p>
<p>SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p>
<p>SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过 passport，子系统本身将不参与登录操作</p>
<p>当一个系统成功登录以后，<code>passport</code>将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被<code>passport</code>授权以后，会建立一个局部会话，在一定时间内可以无需再次向<code>passport</code>发起认证</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/单点登录1.png"/></div></div>
<p>上图有四个系统，分别是<code>Application1</code>、<code>Application2</code>、<code>Application3</code>、和<code>SSO</code>，当<code>Application1</code>、<code>Application2</code>、<code>Application3</code>需要登录时，将跳到<code>SSO</code>系统，<code>SSO</code>系统完成登录，其他的应用系统也就随之登录了</p>
<p>淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录</p>
<h3 id="2-如何实现"><a href="#2-如何实现" class="headerlink" title="2.如何实现"></a>2.如何实现</h3><p><strong>同域名下的单点登录</strong></p>
<p><code>cookie</code>的<code>domain</code>属性设置为当前域的父域，并且父域的<code>cookie</code>会被子域所共享。<code>path</code>属性默认为<code>web</code>应用的上下文路径</p>
<p>利用 <code>Cookie</code>的这个特点，没错，我们只需要将<code>Cookie</code>的<code>domain</code>属性设置为父域的域名（主域名），同时将<code>Cookie</code>的<code>path</code>属性设置为根路径，将 <code>Session ID（或 Token）</code>保存到父域中。这样所有的子域应用就都可以访问到这个<code>Cookie</code></p>
<p>不过这要求应用系统的域名需建立在一个共同的主域名之下，如 <code>tieba.baidu.com</code> 和 <code>map.baidu.com</code>，它们都建立在 <code>baidu.com</code>这个主域名之下，那么它们就可以通过这种方式来实现单点登录</p>
<p><strong>不同域名下的单点登录(一)</strong></p>
<p>如果是不同域的情况下，<code>Cookie</code>是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的<code>Web</code>服务</p>
<p>用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 <code>token</code> 写入 <code>Cookie</code>（注意这个 <code>Cookie</code>是认证中心的，应用系统是访问不到的）</p>
<p>应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心</p>
<p>由于这个操作会将认证中心的 <code>Cookie</code> 自动带过去，因此，认证中心能够根据 <code>Cookie</code> 知道用户是否已经登录过了</p>
<p>如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录</p>
<p>如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 <code>URL</code>，并在跳转前生成一个 <code>Token</code>，拼接在目标 <code>URL</code>的后面，回传给目标应用系统</p>
<p>应用系统拿到 <code>Token</code>之后，还需要向认证中心确认下 <code>Token</code> 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将<code>Token</code>写入 <code>Cookie</code>，然后给本次访问放行。（注意这个 <code>Cookie</code> 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 <code>Token</code>，应用系统验证 <code>Token</code> 发现用户已登录，于是就不会有认证中心什么事了</p>
<p>此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法</p>
<p><strong>不同域名下的单点登录(二)</strong><br>可以选择将 <code>Session ID （或 Token ）</code>保存到浏览器的 <code>LocalStorage</code> 中，让前端在每次向后端发送请求时，主动将<code>LocalStorage</code>的数据传递给服务端</p>
<p>这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 <code>Session ID（或 Token）</code>放在响应体中传递给前端</p>
<p>单点登录完全可以在前端实现。前端拿到 <code>Session ID（或 Token ）</code>后，除了将它写入自己的 <code>LocalStorage</code> 中之外，还可以通过特殊手段将它写入多个其他域下的 <code>LocalStorage</code> 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 token</span></span><br><span class="line"><span class="keyword">var</span> token = result.<span class="property">data</span>.<span class="property">token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML</span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>)</span><br><span class="line">iframe.<span class="property">src</span> = <span class="string">&#x27;http://app1.com/localstorage.html&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(iframe)</span><br><span class="line"><span class="comment">// 使用postMessage()方法将token传递给iframe</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(token, <span class="string">&#x27;http://app1.com&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">4000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  iframe.<span class="title function_">remove</span>()</span><br><span class="line">&#125;, <span class="number">6000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;token&#x27;</span>, event.<span class="property">data</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>前端通过 <code>iframe+postMessage()</code> 方式，将同一份<code>Token</code>写入到了多个域下的 <code>LocalStorage</code> 中，前端每次在向后端发送请求之前，都会主动从 <code>LocalStorage</code> 中读取<code>Token</code>并在请求中携带，这样就实现了同一份<code>Token</code>被多个域所共享</p>
<p>此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域</p>
<h3 id="3-流程"><a href="#3-流程" class="headerlink" title="3.流程"></a>3.流程</h3><p>单点登录的流程图如下所示：</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="../image/article/前端md/单点登录流程.png"/></div></div>
<p>用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</p>
<p>sso 认证中心发现用户未登录，将用户引导至登录页面</p>
<p>用户输入用户名密码提交登录申请</p>
<p>sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌</p>
<p>sso 认证中心带着令牌跳转会最初的请求地址（系统 1）</p>
<p>系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效</p>
<p>sso 认证中心校验令牌，返回有效，注册系统 1</p>
<p>系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</p>
<p>用户访问系统 2 的受保护资源</p>
<p>系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</p>
<p>sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌</p>
<p>系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效</p>
<p>sso 认证中心校验令牌，返回有效，注册系统 2</p>
<p>系统 2 使用该令牌创建与用户的局部会话，返回受保护资源</p>
<p>用户登录成功之后，会与<code>sso</code>认证中心及各个子系统建立会话，用户与<code>sso</code>认证中心建立的会话称为全局会话</p>
<p>用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过<code>sso</code>认证中心</p>
<p>全局会话与局部会话有如下约束关系：</p>
<li>局部会话存在，全局会话一定存在</li>
<li>全局会话存在，局部会话不一定存在</li>
<li>全局会话销毁，局部会话必须销毁</li>

<p>123456789</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>赏口饭吃┭┮﹏┭┮</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://demo.bobovo.cc/posts/056.html">https://demo.bobovo.cc/posts/056.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>BoBOvO</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-03-15</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-03-15</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%F0%9F%96%A5%EF%B8%8F%E4%BB%A3%E7%A0%81/">🖥️代码</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/前端.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/056454.html" title="TypeScript的学习"><img class="cover" src="/../image/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/typescript.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TypeScript的学习</div></div></a></div><div class="next-post pull-right"><a href="/posts/52e0f7b3.html" title="footer自定义和徽标的制作"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">footer自定义和徽标的制作</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/e563214.html" title="Markdown语法(自用)"><img class="cover" src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/markdown.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="title">Markdown语法(自用)</div></div></a></div><div><a href="/posts/52e0f7b3.html" title="footer自定义和徽标的制作"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-08</div><div class="title">footer自定义和徽标的制作</div></div></a></div><div><a href="/posts/056454.html" title="TypeScript的学习"><img class="cover" src="/../image/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/typescript.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="title">TypeScript的学习</div></div></a></div><div><a href="/posts/0.html" title="赏口饭吃┭┮﹏┭┮"><img class="cover" src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/前端.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-08</div><div class="title">赏口饭吃┭┮﹏┭┮</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><!--.avatar-img  本身与注释那一个缩进相同img(src=url_for(theme.avatar.img) onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.flink) + `'` alt="avatar")--><div class="card-info-avatar"><div class="avatar-img"><img src="/image/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/1675585138487.jpg">✨</g-emoji><span>冲冲冲！！</span></div></div></div><div class="author-info__name">BoBOvO</div><div class="author-info__description">自己的小窝</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="/about/"><!--头向下按钮 前图标--><!--i(class=theme.aside.card_author.button.icon)--><span>🍭🍭前往小家🍭🍭</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/bob-bzh" target="_blank" title="Github"><svg class="social_icon" aria-hidden="true"><use xlink:href="#icon-bloggithub"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:2950253898@qq.com" target="_blank" title="Email"><svg class="social_icon" aria-hidden="true"><use xlink:href="#icon-blogmail"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://leetcode.cn/" target="_blank" title="leetcode"><svg class="social_icon" aria-hidden="true"><use xlink:href="#icon-blogleetcode"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/image/WeChat.jpg" target="_blank" title="WeChat"><svg class="social_icon" aria-hidden="true"><use xlink:href="#icon-blogweixin"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://res.abeim.cn/api/qq/?qq=2950253898" target="_blank" title="QQ"><svg class="social_icon" aria-hidden="true"><use xlink:href="#icon-blogqq"></use></svg></a></div></div><div class="card-widget card-announcement"><div id="welcome-info"></div><div class="item-headline"><span>BoBOvOの留言</span></div><div class="announcement_content">欢迎光临!有问题评论区交流！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E7%B3%BB%E5%88%97"><span class="toc-text">JavaScript 系列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%AD%98%E5%82%A8%E5%B7%AE%E5%88%AB"><span class="toc-text">JavaScript 中的数据类型 存储差别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%98%E5%82%A8%E5%8C%BA%E5%88%AB"><span class="toc-text">3.存储区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">数组的常用方法有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-text">1.操作方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E"><span class="toc-text">增</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0"><span class="toc-text">删</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9"><span class="toc-text">改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5"><span class="toc-text">查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="toc-text">2.排序方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-text">3.转换方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95"><span class="toc-text">4.迭代方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6"><span class="toc-text">JavaScript 中的类型转换机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.显示转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.隐式转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">深拷贝和浅拷贝的区别？如何实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8"><span class="toc-text">1.数据类型存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">2.浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">3.深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8C%BA%E5%88%AB"><span class="toc-text">4.区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">对闭包的理解，使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1.是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">3.注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">对作用域链的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">1.作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">2.词法作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">3.作用域链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-text">JavaScript 原型，原型链，有什么特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%9F%E5%9E%8B"><span class="toc-text">1.原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">2.原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%BB%E7%BB%93"><span class="toc-text">3.总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-text">JavaScript 怎么实现继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-text">1.是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">2.实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%BB%E7%BB%93-1"><span class="toc-text">3.总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-this-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">谈谈 this 对象的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99"><span class="toc-text">2.绑定规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">3.箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">4.优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A-VS-%E6%98%BE%E7%A4%BA%E7%BB%91%E5%AE%9A"><span class="toc-text">隐式绑定 VS 显示绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E7%BB%91%E5%AE%9A-VS-%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-text">new 绑定 VS 隐式绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E7%BB%91%E5%AE%9A-VS-%E6%98%BE%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-text">new 绑定 VS 显式绑定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88"><span class="toc-text">JavaScript 中执行上下文和执行栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-text">JavaScript 事件模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-text">1.事件与事件流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.事件模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-%E4%B8%8E-instanceof-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">typeof 与 instanceof 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-typeof"><span class="toc-text">1.typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-instanceof"><span class="toc-text">2.instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8C%BA%E5%88%AB"><span class="toc-text">3.区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">什么是事件代理？应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-text">1.是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%BB%E7%BB%93-2"><span class="toc-text">3.总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">new 操作符具体干了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-text">1.是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%81%E7%A8%8B"><span class="toc-text">2.流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%8B%E5%86%99-new-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.手写 new 操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax-%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">ajax 原理是什么？如何实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88-4"><span class="toc-text">1.是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-text">2.实现过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%81%E8%A3%85"><span class="toc-text">3.封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bind-call-apply-%E5%8C%BA%E5%88%AB"><span class="toc-text">bind,call,apply 区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8"><span class="toc-text">1.作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">正则表达式的理解 应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88-5"><span class="toc-text">1.是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-text">2.匹配规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">对事件循环的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88-6"><span class="toc-text">1.是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-text">2.宏任务与微任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-%E4%B8%8E-await"><span class="toc-text">async 与 await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">4.流程分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">JavaScript 内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88-7"><span class="toc-text">1.是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">2.垃圾回收机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">JavaScript 本地存储方式 区别及应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B9%E5%BC%8F"><span class="toc-text">1.方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8C%BA%E5%88%AB"><span class="toc-text">2.区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3.应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">JavaScript 数字精度丢失的问题,如何解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9C%BA%E6%99%AF%E5%A4%8D%E7%8E%B0"><span class="toc-text">1.场景复现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-text">2.浮点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">3.问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">4.解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-text">什么是防抖和节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88-8"><span class="toc-text">1.是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8C%BA%E5%88%AB-1"><span class="toc-text">3.区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4.应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E5%86%85"><span class="toc-text">如何判断一个元素是否在可视区域内</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E9%80%94"><span class="toc-text">1.用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="toc-text">2.实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">3.案例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E5%81%9A%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-text">大文件如何做断点续传</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88-9"><span class="toc-text">1.是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3.使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0"><span class="toc-text">如何实现上拉加载，下拉刷新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1.前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">2.实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B"><span class="toc-text">3.案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-text">什么是单点登录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B5%81%E7%A8%8B"><span class="toc-text">3.流程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/0001.html" title="今日书摘"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="今日书摘"/></a><div class="content"><a class="title" href="/posts/0001.html" title="今日书摘">今日书摘</a><time datetime="2023-06-20T00:00:00.000Z" title="发表于 2023-06-20 00:00:00">2023-06-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/056454.html" title="TypeScript的学习"><img src="/../image/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/typescript.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScript的学习"/></a><div class="content"><a class="title" href="/posts/056454.html" title="TypeScript的学习">TypeScript的学习</a><time datetime="2023-03-20T00:00:00.000Z" title="发表于 2023-03-20 00:00:00">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/056.html" title="赏口饭吃┭┮﹏┭┮"><img src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/前端.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="赏口饭吃┭┮﹏┭┮"/></a><div class="content"><a class="title" href="/posts/056.html" title="赏口饭吃┭┮﹏┭┮">赏口饭吃┭┮﹏┭┮</a><time datetime="2023-03-15T00:00:00.000Z" title="发表于 2023-03-15 00:00:00">2023-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/52e0f7b3.html" title="footer自定义和徽标的制作"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="footer自定义和徽标的制作"/></a><div class="content"><a class="title" href="/posts/52e0f7b3.html" title="footer自定义和徽标的制作">footer自定义和徽标的制作</a><time datetime="2023-02-08T00:00:00.000Z" title="发表于 2023-02-08 00:00:00">2023-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/0.html" title="赏口饭吃┭┮﹏┭┮"><img src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/前端.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="赏口饭吃┭┮﹏┭┮"/></a><div class="content"><a class="title" href="/posts/0.html" title="赏口饭吃┭┮﹏┭┮">赏口饭吃┭┮﹏┭┮</a><time datetime="2023-02-08T00:00:00.000Z" title="发表于 2023-02-08 00:00:00">2023-02-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/tags/Butterfly">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/changelog/">更新日志</a><a href="/talks/">我的唠叨</a></li><li><a href="/box/Gallery/">我的画廊</a><a target="_blank" rel="noopener" href="https://v6.51.la/report/overview?comId=233144">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://ichika.cc/" title="ichikaの小窝"><img src="https://ichika.cc/img/Page/HeadIcon.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.qcqx.cn/" title="轻笑Chuckle"><img src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/轻笑Chuckle.webp" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://tzy1997.com/" title="唐志远の博客"><img src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/tangzhiyuan.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="安知鱼"><img src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/anzhiyu.png" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://akilar.top/" title="Akilarの糖果屋"><img src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/akilar.top.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.imcharon.com/" title="小N同学"><img src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/nesxc.webp" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.yunyoujun.cn/" title="云游君"><img src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/yunyoujun.webp" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://butterfly.zhheo.com/" title="Butterfly主题美化教程"><img src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/logo.png" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022 - 2023</b></span><span><b>&nbsp;&nbsp;By BoBOvO</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="nav-music"><meting-js id="8111656844" server="netease" fixed="true" type="playlist" mini="true" mutex="true" listfolded="true" preload="none" theme="#ad7a86" data-lrctype="0" order="list"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comment.bobovo.cc/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comment.bobovo.cc/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="/js/runtime.js"></script><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script async data-pjax  src="/js/location.js"></script><script src="/js/randomblog.js"></script><script data-pjax src="/js/nav.js"></script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="//at.alicdn.com/t/c/font_3722848_fkc0hwsdxsc.js"></script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JxhjNEg3AkRtKlWN",ck:"JxhjNEg3AkRtKlWN",hashMode:true})</script><script async data-pjax src="/js/custom.js"></script><script async data-pjax src="/js/waterfall/waterfall.js"></script><script src="/js/title.js"></script><script async data-pjax src="/js/music.js"></script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div class="aplayer no-destroy" data-id="8111656844" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="-1"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://picbed.saop.cc/js/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/056.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/前端.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-15</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/056.html&quot;);" href="javascript:void(0);" alt="">赏口饭吃┭┮﹏┭┮</a><div class="blog-slider__text">面经js</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/056.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/0.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/前端.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-08</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/0.html&quot;);" href="javascript:void(0);" alt="">赏口饭吃┭┮﹏┭┮</a><div class="blog-slider__text">面经</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/0.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/056454.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="../image/文章封面/typescript.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/056454.html&quot;);" href="javascript:void(0);" alt="">TypeScript的学习</a><div class="blog-slider__text">TS</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/056454.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1151b7bc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/js.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1151b7bc.html&quot;);" href="javascript:void(0);" alt="">js一些方法</a><div class="blog-slider__text">第2第2</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1151b7bc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/470f1c7e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/微信图片_20230130010348.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/470f1c7e.html&quot;);" href="javascript:void(0);" alt="">HEXO零星魔改</a><div class="blog-slider__text">技术欠佳，希望能和大家一起成长！！！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/470f1c7e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/52e0f7b3.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-08</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/52e0f7b3.html&quot;);" href="javascript:void(0);" alt="">footer自定义和徽标的制作</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/52e0f7b3.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/51b1ea0a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/css.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/51b1ea0a.html&quot;);" href="javascript:void(0);" alt="">css代码</a><div class="blog-slider__text">没见过没见过😭</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/51b1ea0a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/86920a4a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/微信图片_20230130010348.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-04</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/86920a4a.html&quot;);" href="javascript:void(0);" alt="">关于我-页面魔改</a><div class="blog-slider__text">技术欠佳，希望能和大家一起成长！！！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/86920a4a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e563214.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://cdn.staticaly.com/gh/bob-bzh/picgo_pic@main/img/markdown.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e563214.html&quot;);" href="javascript:void(0);" alt="">Markdown语法(自用)</a><div class="blog-slider__text">常用的一些标签</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e563214.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>